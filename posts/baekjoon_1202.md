---
title: "백준 1202번 보석 도둑 (python)"
date: "2026-01-08 17:02:18"
category: "코테"
description: "python으로 풀어보는 백준 1202"
---

## 코딩 테스트 풀이

!["문제사진"](/images/1202.png)
<a href="https://www.acmicpc.net/problem/1202" class="plink">
  문제링크
</a>

백준 1202번 문제 풀이에 대한 해설.

### 나의 접근
처음에는 제한된 가방에 특정 조건을 갖춘 무게를 채우기라는 표현때문에 <b>DP(냅색)</b>이라고 생각했었다.

하지만 냅색과는 다르게 별도의 가방이 존재하고 무게가 다 다르다는 조건이 있어서 특정 가방에 특정 보석을 무엇을 담았는지를
판별해야 하는데 이러면 비트마스킹이 되어 버릴 것이다.

하지만 비트마스킹으로 풀기엔 $N$과 $K$가 너무 컸기 때문에 절대 안 된다는 걸 파악하고 그 다음엔 아이디어 떠오르지 않아서
문제의 카테고리를 보았다.

이 문제는 <b>Greedy</b> 알고리즘으로, 더 구체적으로는 <b>정렬</b>과 <b>Heap</b>을 사용해서 풀 수 있는 문제였다.

먼저 어느 걸 위주로 판단을 할지 생각해보자. 어떤 보석을 어떤 가방에 담을까라고 생각하면 적절한 가방을 탐색하는 비용이 발생한다.
반면 가방에 어느 것까지 담을 수 있지를 생각해보면 좀 더 쉽다.

만약에 $A,B,C$라는 보석이 있고 무게가 $A < B < C$라고 가정해보자.  
특정 가방 `bag[i]`가 $C$만큼의 무게가 나간다면 $A,B,C$ 모두 이 가방에 담을 수 있을 것이다. 그럼 이제 `bag[i+1]`을 생각해보자.
`bag[i+1]`은 `bag[i]`보다 무게가 같거나 크기 때문에 똑같이 $A,B,C$를 담을 수 있다.

즉, 각 가방 위주로 탐색을 시도하게 되면, 누적되는 후보군들 덕분에 보석에 대한 탐색을 곱사건($O(NK)$)이 아니라 <b>각 배열을 한 번씩만 훑는 선형적인 흐름</b>($O(N+K)$)으로 바꿀 수 있다. 

이미 힙에 들어간 보석들은 다음 가방(더 큰 가방)에서도 여전히 유효한 후보이므로, **검사했던 보석을 다시 검사할 필요 없이 포인터만 앞으로 이동시키면 되기 때문**이다.

따라서 가방과 보석 둘 다 <b>무게를 기준으로 오름차순</b>으로 정렬을 하고, 모든 가방을 탐색하면 동시에 보석을 순회할 순차적으로 증가하는
변수 `idx`를 통해 해당 가방의 무게 이하의 보석을 전부 Heap에 담아 보석 후보군을 만든다.

이때 Heap의 성질을 살려서 최소힙을 유지하기 위해 보석의 값을 음수로 넣고, 이 음수들 중 가장 작은 수를 `heapq.heappop()`을 통해서
꺼내면 된다.

### 정답 코드
```python
from sys import stdin as input
import heapq

n,k = map(int,input.readline().split())

# 각 보석은 무게와 가격
arr = [list(map(int,input.readline().split())) for _ in range(n)]
# 무게 오름차순
arr.sort(key=lambda x: x[0])
# 가방은 담을 수 있는 무게
bag = [int(input.readline()) for _ in range(k)]
# 무게 오름차순
bag.sort()

ans = 0
q = []
idx = 0
# 무게가 작은 가방부터 시작
for i in range(k):
    w = bag[i]
    # w보다 작은 무게의 보석을 모두 heap에 담기
    while idx < len(arr):
        v,c = arr[idx]
        if v <= w:
            heapq.heappush(q,-c)
            idx += 1
        else: break
    if q:
        cost = heapq.heappop(q)
        ans += cost
print(-ans)
```
