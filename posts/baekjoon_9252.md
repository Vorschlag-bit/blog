---
title: "백준 9252번 LCS 2 (python)"
date: "2025-12-27 03:44:35"
category: "코테"
description: "python으로 풀어보는 백준 9252"
---

## 코딩 테스트 풀이

!["문제사진"](/images/9252.png)
<a href="https://www.acmicpc.net/problem/9252" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 9252번 문제 풀이에 대한 해설.

### 나의 접근
LCS는 대표적인 DP 문제이다. LCS를 설명하는 건 훌륭한 유튜브 영상들이 많으니 이것들을 참고하면 좋을 거 같다.
<a class="plink" href="https://www.youtube.com/watch?v=z8KVLz9BFIo">
    LCS 유튜브 설명 강의(주니온 TV)
</a>. 이 강의를 보면 LCS에 대한 최적해를 찾아나가는 과정을 최악의 시간 복잡도에서부터 최적의 시간 복잡도로 바꿔나가는데

그 과정에서 가장 중요한 것이 DP의 Memorization을 통한 중복 계산을 없얘는 것이다.

### 점화식 도출
LCS를 구하는 핵심 로직은 두 문자열의 문자를 하나씩 비교하며 2차원 배열(`dp`)을 채워나가는 것이다. `dp[i][j]`는 문자열 A의 `i`번째 글자와 문자열 B의 `j`번째 글자까지 비교했을 때의 최장 공통 부분 수열의 길이를 의미한다.

경우는 크게 두 가지로 나뉜다.

1.  **두 문자가 같을 때 (`a[i-1] == b[j-1]`):**
    현재 문자가 LCS에 포함된다는 뜻이다. 대각선 왼쪽 위(`dp[i-1][j-1]`)의 값에 1을 더해준다. 과거의 최적해에 현재 글자 하나가 추가되는 셈이다.
    $$dp[i][j] = dp[i-1][j-1] + 1$$

2.  **두 문자가 다를 때:**
    LCS가 늘어나지 않는다. 대신 이전까지 구했던 최적해를 유지해야 하므로, 위쪽(`dp[i-1][j]`)이나 왼쪽(`dp[i][j-1]`) 중 더 큰 값을 그대로 가져온다.
    $$dp[i][j] = \max(dp[i-1][j], dp[i][j-1])$$

이 과정을 통해 `dp[n][m]`에는 최종적으로 LCS의 **길이**가 저장된다.

### 역추적 (문자열 구하기)
단순히 길이만 구하는 문제라면 여기서 끝났겠지만, 이 문제는 LCS **문자열 자체**를 출력해야 한다. 따라서 완성된 DP 테이블의 끝점(`dp[n][m]`)에서 시작해 다시 원점(`0,0`)으로 돌아가는 **역추적** 과정이 필요하다.

로직은 DP를 채울 때와 반대로 생각하면 된다.

1.  현재 보고 있는 두 문자가 **같다면**:
    이 문자는 LCS의 일원이므로 정답 리스트에 추가하고, **대각선 왼쪽 위**로 이동한다. (`n-1`, `m-1`)
2.  두 문자가 **다르다면**:
    점수가 갱신되지 않고 그대로 내려온 곳으로 이동해야 한다.
    *   만약 `dp[n][m]`이 바로 위쪽(`dp[n-1][m]`)과 같다면 **위로** 이동.
    *   아니라면(왼쪽과 같다면) **왼쪽으로** 이동.

이 과정을 반복하면 뒤에서부터 문자를 찾게 되므로, 마지막에 문자열을 **뒤집어주면(Reverse)** 정답이 된다.

### 정답 코드
```python
from sys import stdin as input

# 첫 번쨰 줄에 lcs 길이
# 두 번째 줄에 lcs 자체
# dp[i][j] = lcs(i,j) -> max(dp[i][j], dp[i][j-1])
a = input.readline().strip()
b = input.readline().strip()
n = len(a)
m = len(b)
dp = [[0] * (m+1) for _ in range(n+1)]

ans = ''
# 역추적  1 = i-1,j-1, 2 = i-1, 3 = j-1

for i in range(1,n+1):
    for j in range(1,m+1):
        # 서로 같을 경우
        if a[i-1] == b[j-1]:
            dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1)
        else:
            if dp[i-1][j] > dp[i][j-1]:
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = dp[i][j-1]

print(dp[n][m])
while n > 0 and m > 0:
    if a[n-1] == b[m-1]:
        ans += a[n-1]
        n -= 1
        m -= 1
    else:
        # 위쪽이랑 같은 경우
        if dp[n][m] == dp[n-1][m]:
            n -= 1
        # 왼쪽이랑 같은 경우
        else:
            m -= 1
print(ans[::-1]) 

```
