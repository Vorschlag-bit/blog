---
title: "Virtual DOM과 렌더링의 원리: React는 정말 빠를까?"
date: "2025-12-22 17:13:56"
category: "React"
description: "가상 돔(Virtual DOM)의 진짜 목적과 브라우저 렌더링 파이프라인 심층 분석"
---

<img src="/images/react_icon.svg" alt="React 로고" width="400" height="400" />

## 서론: DOM vs Virtual DOM

"React는 가상 돔(Virtual DOM)을 사용해서 빠르다."

React를 공부하다 보면 가장 먼저 접하는 문장이다. 하지만 **정말 그럴까?** 단순히 중간 단계(가상 돔)를 거치는 것이 어떻게 직접 수정하는 것보다 빠를 수 있을까? 결론부터 말하자면 React가 무조건 빠른 것은 아니다.

이 글에서는 React가 **왜 가상 돔을 도입했는지**, 그리고 **브라우저의 렌더링 과정에서 어떤 이점을 가져가는지** 엔지니어링 관점에서 파헤쳐본다.

---

## 1. 브라우저 렌더링 과정의 병목 (The Bottleneck)

가상 돔의 필요성을 이해하려면 먼저 브라우저가 화면을 그리는 과정(Critical Rendering Path)을 알아야 한다.

1.  **HTML 파싱**: DOM Tree 생성
2.  **CSS 파싱**: CSSOM Tree 생성
3.  **Render Tree 결합**: 실제 화면에 표시될 요소들로 구성된 트리 생성
4.  <b>Layout (Reflow)</b>: 각 요소의 위치와 크기 계산 (기하학적 계산, 가장 비쌈)
5.  <b>Paint (Repaint)</b>: 픽셀을 화면에 그림 (시각적 처리)
6.  **Composite**: 레이어 합성

### 1-1. Reflow (Layout): 대공사 발생
Reflow는 **요소의 위치나 크기가 변경되었을 때, 브라우저가 레이아웃을 다시 계산하는 과정**이다.
- **발생 원인**: `width`, `height`, `padding`, `margin`, `font-size` 변경, 브라우저 창 크기 조절 등.
- **특징**:
    - **가장 비싼 작업**: 단순한 그림 그리기가 아니라 모든 요소의 좌표를 다시 계산해야 한다. 주로 CPU를 많이 사용한다.
    - **전파(Propagation)**: 부모 노드의 크기가 바뀌면 자식 노드는 물론, 형제 노드까지 밀려나거나 당겨지면서 레이아웃이 연쇄적으로 다시 계산된다.
    - **Repaint 필연적 동반**: 위치나 크기가 바뀌면 당연히 다시 그려야 하므로, **Reflow는 무조건 Repaint를 일으킨다.**

### 1-2. Repaint (Paint): 인테리어 공사
Repaint는 레이아웃에는 영향을 주지 않지만, **요소의 시각적인 표현(색상, 스타일 등)이 변경되었을 때** 발생한다.
- **발생 원인**: `color`, `background-color`, `visibility`, `border-radius` 등.
- **특징**:
    - **비교적 저렴**: 위치 계산(기하학) 단계가 생략되므로 Reflow보다는 가볍다. 주로 GPU 가속을 활용할 수 있다.
    - **전파 없음**: 본인의 색상만 바뀌는 것이므로 다른 요소(부모, 자식)의 레이아웃이나 페인팅에 영향을 주지 않는다.

> **성능 최적화의 핵심**:
> 렌더링 성능을 높이려면 **Reflow를 최대한 피하고, 어쩔 수 없다면 Repaint만 발생하도록** 유도해야 한다. (예: `top/left` 대신 `transform` 사용)

### 1-3. 강제 동기 레이아웃 (Layout Thrashing)
문제는 브라우저의 최적화 메커니즘을 개발자가 깨뜨릴 때 발생한다.
브라우저는 성능을 위해 여러 스타일 변경을 최적화 큐(Queue)에 모았다가 한 번에 처리하려 한다.  

하지만 자바스크립트에서 변경 직후 `offsetHeight`나 `scrollTop` 같은 **계산된 스타일**을 읽으려 하면, 브라우저는 정확한 값을 반환하기 위해 큐를 무시하고 **즉시 Reflow를 강제로 수행**해야 한다. 

이 과정이 반복되면 메인 스레드는 연산하느라 바빠져 사용자 입력(클릭, 스크롤)을 받지 못하는 <b>프리징(Freezing)</b> 상태에 빠진다.

---

## 2. 의문점: Vanilla JS만으로 최적화할 수는 없을까?

여기서 한 가지 의문이 든다. *"브라우저도 자체적인 최적화 큐(Queue)가 있으니, 개발자가 Vanilla JS로 코드를 잘 짜면 React보다 더 빠른 것 아닐까?"*

**정답은 "그렇다"이다.** 이론적으로, 그리고 극한으로 최적화된 Vanilla JS는 가상 돔을 거치는 React보다 빠르다. 하지만 실무에서 이를 완벽하게 수행하기엔 **두 가지 치명적인 한계**가 있다.

### 2-1. 최적화 큐의 불안정성 (Human Error)
브라우저의 최적화 큐는 '유리 멘탈'과 같다. 개발자가 코드 한 줄만 잘못 작성해도(예: 스타일 변경 후 즉시 크기 읽기) 최적화는 깨져버린다. 수만 줄의 코드에서 이런 실수를 100% 방지하는 것은 불가능에 가깝다.

### 2-2. 유지보수의 복잡도 (N:M 문제)
데이터 하나가 바뀌었을 때, 화면의 어떤 부분들(Header, List, Footer...)을 업데이트해야 하는지 개발자가 일일이 추적해야 한다 (`querySelector` -> `innerText` 변경). 애플리케이션 규모가 커질수록 이 의존성을 관리하는 코드는 스파게티가 되기 십상이다.

---

## 3. React의 해결책: Virtual DOM과 Batching

React는 이 문제를 해결하기 위해 메모리에 <b>가상의 DOM(JavaScript 객체)</b>을 둔다. 핵심은 <b>"안전한 자동화"</b>다.

### 안전한 Batch Update (일괄 처리)
React는 상태(State)가 변경되면 바로 실제 DOM을 건드리지 않는다.
1.  <b>Render Phase(Diffing)</b>: 새로운 가상 돔을 만들고 이전 것과 비교하여 변경 사항을 수집한다. (순수 계산 영역)
2.  <b>Commit Phase(Reconciliation)</b>: 계산된 최종 변경 사항만 실제 DOM에 **한 번에** 적용한다.

이 구조 덕분에 개발자가 실수로 레이아웃을 강제로 발생시키는 코드를 짜더라도, React 내부에서 렌더링 시점을 조절하여 실제 DOM 접근 횟수를 최소화한다. 즉, <b>브라우저의 최적화 큐가 깨지지 않도록 보호하는 역할</b>을 한다.

---

## 4. 재조정(Reconciliation) 알고리즘

React가 매번 가상 돔 전체를 새로 그리면 느리지 않을까? React는 $O(N^3)$의 트리 비교 복잡도를 두 가지 가정(Heuristic)을 통해 $O(N)$으로 줄였다.

### 4-1. 서로 다른 타입은 다른 트리다
`<div>`가 `<span>`으로 바뀌면, React는 내부를 비교하지 않고 해당 트리를 통째로 버리고 새로 만든다. (Unmount -> Mount)

### 4-2. Key Props를 통한 식별
리스트를 렌더링할 때 `key`가 필수인 이유다.
*   **Key 없음**: 리스트 순서만 바뀌어도 React는 "내용이 바뀌었네?"라고 착각하여 전체를 다시 그릴 수 있다.
*   **Key 있음**: "아, 3번 아이템이 1번 자리로 이동만 했구나"라고 파악하여 DOM 요소를 재사용한다.

---

## 5. 결론: "속도"가 아닌 "유지보수성"

다시 처음 질문으로 돌아가보자. **React는 무조건 빠른가?**

아니다. React는 <b>가상 돔 생성 및 비교(Diffing)</b>라는 자바스크립트 연산 비용(Overhead)을 추가로 지불한다. 따라서 핀포인트로 DOM을 수정하는 최적화된 Vanilla JS보다 빠를 수는 없다. Svelte나 SolidJS 같은 최신 라이브러리들이 가상 돔을 버리는 추세인 이유기도 하다.

하지만 React 팀과 생태계가 추구하는 가치는 명확하다.

### 5-1. 유지보수성 (Maintenance)
React는 <b>"무엇(What)을 그릴지"</b>만 선언하면 <b>"어떻게(How) 업데이트할지"</b>는 알아서 처리한다. 개발자는 DOM 조작이라는 복잡한 로직에서 해방되어 비즈니스 로직에 집중할 수 있다.

### 5-2. 충분히 빠르다 (Sufficiently Fast)
React는 "세상에서 제일 빠른 속도"가 아니라 <b>"사용자가 불편함을 느끼지 않을 정도(16ms, 60fps)의 속도"</b>를 안정적으로 보장하는 것을 목표로 한다.

최근 React 18의 **동시성 모드(Concurrent Mode)** 역시 절대적인 렌더링 속도를 높이는 것이 아니라, 렌더링 중에도 사용자 입력에 반응할 수 있도록 <b>반응성(Responsiveness)</b>을 높이는 데 초점이 맞춰져 있다.

결국 React를 선택한다는 것은, <b>"극한의 기계적 성능"을 조금 양보하고 "개발자의 생산성"과 "안정적인 사용자 경험"을 얻는 현명한 트레이드오프(Trade-off)</b>인 셈이다.