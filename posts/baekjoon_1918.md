---
title: "백준 1918번 후위 표기식 (python)"
date: "2025-12-22 15:31:36"
category: "코테"
description: "python으로 풀어보는 백준 1918"
---

## 코딩 테스트 풀이

!["문제사진"](/images/1918.png)
<a href="https://www.acmicpc.net/problem/1918" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 1918번 문제 풀이에 대한 해설.

### 나의 접근
괄호를 통해서 쌍을 맞춰간다는 조건을 통해서 <b>스택(Stack)</b>을 활용하는 문제라는 걸 파악할 수 있었다.  
또한 우선순위라는 키워드가 있었기 때문에 스택의 성질인 <b>내림/오름차순 유지</b>를 통해서 연산자간의 관계를 통해 올바른 순서로 출력을 하면 되겠다 싶었다.

문제의 예시인 $$a + b * c - d / e$$같은 경우 우선순위를 주어 괄호로 묶으면 $$(a + (b * c)) - (d / e)$$가 된다.  
이 때 가운데 -를 위한 괄호로 가장 바깥을 묶고 연산자만 쌓는 스택을 만들어서 괄호가 닫힐 때마다 pop을 하면 완벽한 후위연산이 된다고 생각했었다.

따라서 정말 문제에 주어진대로 1. 중위 표기식을 연산자 우선순위에 맞춰 괄호로 묶고 2. stack을 통해서 괄호가 닫힐 때마다 우선순위에 맞게 꺼내기라는
전략으로 문제를 풀려고 했었다.

하지만 $$a * b * c$$와 같은 예시에서 괄호를 감싸는 게 매우 어려웠다, 동일한 우선순위를 갖는 경우에는 왼 -> 오른의 우선순위를 가지나, $$*\ c$$를 만나서
괄호로 묶을 때 이전 인덱스를 따로 기록해놔야 했다. 이런 식으로 예외처리가 매우 빡센 트리 Parser 구현이 될 것만 같아서 이런 방식은 아니라고 판단했다.

곰곰히 생각을 하면서 문자열에 굳이 물리적인 괄호를 씌우지 않더라도 스택 자체가 <b>보이지 않는 괄호</b> 역할을 수행할 수 있다는 걸 파악했다.  
먼저 알파벳은 순서가 전혀 바뀌지 않는다. 곧바로 <code>ans</code>에 추가하면 된다. 연산자의 경우 stack에 머무르다가 <b>"때가 되면"</b> 나가게 될 것이다.

여기서 <b>"알맞은 때"</b>를 어떻게 알 수 있을까?  
경우를 크게 2가지로 나눠보았다.

1. 괄호없는 상태에서 더 큰 우선순위 연산자를 만났을 경우
$$a + b * c$$와 같은 예시가 대표적이다. $$*$$의 차례에서 stack에 자신 이하의 우선순위를 가진 모든 걸 <code>pop()</code>하면 된다.

2. 괄호없는 상태에서 동일한 우선순위 연산자를 만날 경우
$$a * b * c$$가 대표적이다. 하지만 이 역시 첫 번쨰와 마찬가지로 두 번째 곱하기 연산자의 차례에서 자신 이하의 우선순위 연산자를 <code>pop()</code>하면 된다.

하지만 문제에선 여기에 <b>괄호</b>라는 연산자까지 존재한다. 괄호는 일반 연산자와 다르게 매우 특이한 성질을 갖고 있다. 이를 이해하기 위해 $$(A + B * C + D) + E$$라는 예시를 살펴보자.

이 식을 보면 괄호 `( ... )` 안에 있는 연산들(`+`, `*`, `+`)은 괄호 밖에 있는 마지막 `+`보다 무조건 먼저 처리되어야 한다. <b>즉, 여는 괄호 `(`는 스택 안에서 "새로운 바닥(Floor)" 역할을 수행한다.</b>

스택에 `(`가 들어가는 순간, 그 이전에 쌓여있던 연산자들은 잠시 '동결'된다. `(` 이후에 들어오는 연산자들은 마치 빈 스택에 들어오는 것처럼 행동하다가, 닫는 괄호 `)`를 만나면 그때서야 그 "임시 바닥" 위에서 벌어진 일들이 청산되고 `(`가 사라지는 것이다.

따라서 앞서 세운 가설에 **괄호의 규칙**을 추가하여 다음과 같이 최종 로직을 정립할 수 있다.

1.  **여는 괄호 `(`**: 무조건 스택에 넣는다.
    *   우선순위가 가장 높은 것처럼 행동하여 들어가지만, 막상 스택 안에 들어가면 **가장 낮은 우선순위(바닥)** 취급을 받는다. 그래야 뒤따라오는 `+`나 `*`가 `(`를 꺼내지 않고 그 위에 쌓이기 때문이다.
2.  **닫는 괄호 `)`**: `(`를 만날 때까지 스택을 비워낸다.
    *   `(`가 생성한 "임시 바닥" 위에서 쌓인 모든 연산을 처리하고, 괄호 쌍을 소멸시킨다.
3.  **일반 연산자 (`+`, `-`, `*`, `/`)**: 스택의 `top`과 우선순위를 비교한다.
    *   나보다 우선순위가 높거나 같은 연산자는 모두 `pop()`해서 출력한다.
    *   **단, 여는 괄호 `(`는 절대 꺼내지 않는다.** (괄호는 독립된 공간의 경계선이기 때문)

이 로직을 적용하면 $$(A + B * C + D) + E$$의 과정은 다음과 같이 매끄럽게 설명된다.
*   `(`가 스택에 들어가 경계를 짓는다. `Stack: [(]`
*   `+`가 들어온다. `(`는 건드리지 못하므로 쌓인다. `Stack: [(, +]`
*   `*`가 들어온다. `+`보다 우선순위가 높으므로 쌓인다. `Stack: [(, +, *]`
*   두 번째 `+`가 들어온다.
    *   자신보다 높은 `*`를 `pop`한다.
    *   자신과 같은 `+`를 `pop`한다.
    *   `(`는 건드리지 않고 자신이 들어간다. `Stack: [(, +]`
    *   출력: `A B C * +`
*   `D` 출력 후 `)`가 들어온다. `(`를 만날 때까지 `pop`한다. `Stack: []` (괄호 소멸)
*   마지막 `+`와 `E`가 처리된다.

결국 스택을 이용한다는 것은 <b>"연산자의 우선순위를 통해 보이지 않는 괄호를 치는 행위"</b>이며, 진짜 괄호는 <b>"그 행위가 일어나는 독립적인 구간을 나누는 역할"</b>임을 알 수 있다.

### 정답 코드
```python
from sys import stdin as input
# 1. 중위 표기식을 연산자 우선순위에 따라 괄호로 묶기
# 2. 괄호 안의 연산자를 괄호의 오른쪽으로 이동

exp = input.readline().strip()
# 우선순위
p = {'*': 2, '/': 2, '-': 1, '+': 1, '(': 0, ')': 0}
# stack
# A*(B+C)
# a + b * c - d / e
stack = []
ans = ''
for char in exp:
    if char not in p.keys():
        ans += char
    else:
        if char == '(': stack.append(char)
        elif char == ')':
            # 해당 닫힌 괄호의 짝이 되는 여는 괄호까지 다 pop
            while stack and p[stack[-1]] > p[char]:
                ans += stack.pop()
            # 여는 괄호 제거
            stack.pop()
        else:
            # 여는 괄호를 제외한 char 이상의 우선순위 제거(오름차순 유지)
            while stack and stack[-1] != '(' and p[stack[-1]] >= p[char]:
                ans += stack.pop()
            stack.append(char)

while stack:
    char = stack.pop()
    if char not in ['(',')']:
        ans += char

print(ans)
```