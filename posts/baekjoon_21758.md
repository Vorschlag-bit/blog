---
title: "백준 21758번 꿀 따기 (python)"
date: "2025-12-11 23:37:39"
category: "코테"
description: "python으로 풀어보는 백준 21758"
---

## 코딩 테스트 풀이

!["문제사진"](/images/21758.png)
<a href="https://www.acmicpc.net/problem/21758" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 21758번 문제 풀이에 대한 해설.

### 나의 접근
우선 문제가 좀 헷갈려서 꼼꼼히 읽고 문제를 이해했다.  
문제를 봤을 때 역시 **누적합**이 바로 생각이 났었다. 특정 구간의 합을 빠르게 구하는 데에 필수적으로 필요하기 때문이다.

다만 문제는 벌들의 인덱스와 벌통의 인덱스를 어떻게 결정해야할지 몰라서 고민을 했었다.  
$$N$$은 최대 10만이므로 조합을 사용해서 완전탐색을 시도한다면 절대로 불가능할 것이었다.

그렇다고 투 포인터를 사용해서 풀자니 벌통의 위치까지 생각해야 하니까 아니라고 생각했다.  
고민 끝에 일단 문제의 유형이 **그리디**라는 걸 확인했다. 그리디라면 최적의 경우를 분명 몇 가지로 나눌 수 있을 거라고 생각했다.

가장 먼저 문제의 첫 번째 예시가 대표적이다. **벌통을 N에 고정**시키고 1번 벌 역시 1에 고정하고 2번 벌을 움직이면서
최대의 값을 찾으면 될 거 같았다.

사실 반대의 경우도 처음 볼 때는 누적합의 원리상 뭔가 고려할 필요없어 보여서 이거 말고 다른 탐욕적 탐색이 있을까? 라고 생각했으나
**예제 3번**의 경우를 보고 다시 문제를 다시 고민했다. 예제 3번은 $$ [2,5,4] $$로
**양쪽 끝에서 가운데 벌통을 향해** 탐색해야 최댓값인 경우였다.  
이걸 보고서 크게 3가지 경우로 나눌 수 있겠다고 생각했다.

- 1. **벌1을 1번에 고정, 벌통을 N에 고정하고 나머지 벌을 i로 탐색하기**
- 2. **벌1을 N번에 고정, 벌통을 1에 고정하고 나머지 벌을 i로 탐색하기**
- 3. **벌1을 1번에 고정, 벌2를 N에 고정하고 벌통을 i로 탐색하기**

이렇게 3가지 경우로 나누고 $$N$$의 시간복잡도로 한 번만 탐색하면 충분히 해결할 수 있는 문제이다.

### 정답 코드
```python
from sys import stdin as input
n = int(input.readline())
arr = [0] + list(map(int,input.readline().split()))
s = arr[:]
# 최대로 획득할 수 있는 꿀의 양 return
ans = 0

# 누적합
for i in range(n):
    s[i+1] += s[i]

# 로직
# s[n] - s[i-1] - arr[i]

# 벌통의 인덱스를 1 ~ N까지 둠
# 최대가 될 수 있는 건 
# 1. 양 벌 모두 왼쪽에서 -> 방향으로 출발
# 2. 양 벌 모두 오른쪽에서 <- 방향으로 출발
# 3. 각 벌이 왼,오른 끝에서 가운데 벌통으로 출발

for i in range(1,n+1):
    # 1번 케이스(1,i), 벌통은 N
    if i >= 2:
        cur = 0
        # 1번 벌
        cur += s[n] - s[0] - arr[1] - arr[i]
        # i번 벌
        cur += s[n] - s[i-1] - arr[i]
        ans = max(ans, cur)
    
    # 2번 케이스(i,N), 벌통은 1
    if i <= n-1:
        cur = 0
        # n번 벌
        cur += s[n] - s[0] - arr[n] - arr[i]
        # i번 벌
        cur += s[i] - s[0] - arr[i]
        ans = max(ans, cur)

    # 3번 케이스(1,n), 벌통은 i
    if 2 <= i <= n-1:
        cur = 0
        # 1번 벌
        cur += s[i] - s[0] - arr[1]
        # n번 벌
        cur += s[n] - s[i-1] - arr[n]
        ans = max(ans, cur)
print(ans)
```
