---
title: "백준 2157번 여행 (python)"
date: "2025-12-12 14:55:25"
category: "코테"
description: "python으로 풀어보는 백준 2157"
---

## 코딩 테스트 풀이

!["문제사진"](/images/2157.png)
<a href="https://www.acmicpc.net/problem/2157" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 2157번 문제 풀이에 대한 해설.

### 나의 접근
$$1$$에서 출발해 $$N$$으로 도착을 해야하고 중간에 거칠 수 있는 도시의 수는 $$m-2$$개 이하여야 한다는 조건과 루트가 여러 가지 존재할 수 있으며
결국 $$1 \sim N$$의 루트 중 기내식 최댓값을 출력하는데 같은 도시 쌍이여도 가중치가 여러 개일 수 있다는 조건에서 그래프와 이전의 값이
이후의 값에 영향을 주는 걸 보면서 DP 유형임을 파악할 수 있었다.

다만 그래프인 건 알겠는데 이걸 어떻게 활용하라는 건지는 감이 잡히지 않았었다.  
$$i$$라는 도시에서 출발해서 $$j$$라는 도시에 도착할 때 필요한 정보들은 이전까지의 최적화된 값과 방문한 도시의 개수이므로
상태를 측정해야 하니 비트마스킹일까? 싶었으나 상태라기보다는 단순 개수만 세면 되므로 3차원 DP를 생각했다.

그렇게 처음에는  
$$dp[i][j][k] = i에서\ 출발해\ j에\ 도착하고\ 그때\ k개의\ 도시를\ 방문한\ 경우의\ 최댓값$$이라고 dp 테이블을 정의하고 3개의 중첩
반복문을 내부에서 점화식을 세우려고 했는데, 이렇게 정의하고 나니 **이전 상태**에서 값을 넘겨받는 게 불가능한 구조라는 걸 파악했다.

따라서 다시 dp 테이블부터 정의를 새로 했다. 우리가 $$j$$번 도시에 도착했을 때 필요한 건은 딱 2가지이다.  
1. **현재 내가 j번 도시에 있다.**  
2. **지금까지 k개의 도시를 방문했다.**  
이 2가지 조건만 있어도 되는 이유는 이 문제에서 **항공로는 번호가 증가하는 순서($$i < j$$)로만 이동한다**는 말이 있기 때문이다.  
이는 그래프 이론에서 <strong>DAG(Directed Acyclic Graph, 사이클이 없는 방향 그래프)</strong>를 의미하고, 이미 <strong>위상정렬(Topological Sort)</strong>이 되어있다는 걸 나타낸다.

즉 <strong>"i번 도시부터 N번 도시까지 순서대로(`for i in range(1,N+1)` 훑으면서 처리하면, i번 도시를 처리할 때 i번 도시 이전 도시에 대한 계산은 완료가 되어 있다"</strong>는 보장인 셈인 것이다!

그러므로 현재 도시 $$i$$에서 갈 수 있는 도시인 $$j$$에게 값을 뿌려는 형태인
<strong>Push Dp</strong>로 점화식을 구현하면 풀 수 있는 문제였다.

### 정답 코드
```python
from sys import stdin as input

n,m,k = map(int, input.readline().split())
# 최댓값만 저장할 배열 (i -> j, 경로가 없을 경우 -1)
route = [[-1] * (n+1) for _ in range(n+1)]
# 이동은 번호가 증가하는 방향으로만 해야 함(동 -> 서)
for _ in range(k):
    a,b,c = map(int,input.readline().split())
    # 역방향 무시
    if a > b: continue
    route[a][b] = max(route[a][b], c)    

ans = 0

# a번 도시에서 b번 도시로 이동, c점 점수
# 서 -> 동도 입력 가능(가면 안 됌)
# 같은 도시 쌍에 여러 루트가 존재할 수도 있다. 

# 시작은 반드시 1, 도착은 N, 방문한 도시의 합이 m개 이하여야 한다.
# 필요한 게 중간 과정이 전부 다 인가 아니면 바로 이전 도시만 있으면 되는가
# 비트 마스킹으로 하려면, 300 * 2^300 => 불가능

# dp[i][j] = i번 도시에 도착했을 때 j개의 도시를 방문한 상태의 최댓값
dp = [[0] * (m+1) for _ in range(n+1)]

for i in range(1,n):
    for j in range(1,m):
        # i번 도시에서 갈 수 있느 도시에 pushDP로 값을 뿌려주기만 하면 된다
        # 불가능한 조건 pass
        if j > i: continue
        # 1번을 안 거치고 오기
        if i > 1 and j == 1: continue
        for k in range(i+1,n+1):
            # i -> k로 갈 수 있는 방법들
            score = route[i][k]
            # 가는 법 없으면 pass
            if score == -1: continue
            # 중간 길인데 점수가 0이면 안 된다.
            if j > 1 and dp[i][j] == 0: continue
            dp[k][j+1] = max(dp[k][j+1], dp[i][j] + score)

print(max(dp[n]))
```

### 후기
그래프 유형을 나름 많이 풀어봤다고 생각했는데(bfs,다익스트라 등..) **위상정렬** 문제는 사실 거의 안 풀어봤다는 걸 알게 되었다.  

문제의 제한 조건을 쉽게 넘기지 말고 최대한 이 문제를 푸는 힌트라고 생각하고 유형을 분석하는 데에 사용해야 한다는 점을 배울 수 있었다.

**위상 정렬**에 대해서 학습하고 코딩 테스트에서 어떤 식으로 적용되는지 자세히 알아보는 내용의 글을 작성해야겠다.