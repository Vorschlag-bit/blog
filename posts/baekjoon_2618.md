---
title: "백준 2618번 경찰차 (python)"
date: "2025-12-08 14:39:45"
category: "코테"
description: "python으로 풀어보는 백준 2618"
---

## 코딩 테스트 풀이

!["문제사진"](/images/2618.png)
<a href="https://www.acmicpc.net/problem/2618" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 2618번 문제 풀이에 대한 해설.

### 나의 접근
먼저 1초라는 시간복잡도 제한선 때문에 효율적인 계산을 위해서 언뜻보면 bfs로 풀이할 수도 있겠지만, **dp**를 사용해서 푸는 것이
최적화라고 생각을 했었다. 다만 dp 문제들이 그러하듯 dp 테이블에 대한 정의에서 어려움을 겪었다.

처음에 내가 생각한 건 이 문제에 대한 3가지 동적인 변수가 고정되어 있었다고 생각한 것이다.  
**사건의 인덱스, r좌표, c좌표**. 이 3가지 변수에 대한 모든 걸 고려해야 하므로 dp 테이블을 3차원 배열로 생각했었다.
하지만 이렇게 될 경우 $$ 1000^3 $$으로 10억 번의 연산이 필요하므로 절대로 불가능한 수치였다.  
1초라는 시간복잡도를 기반으로 dp 테이블을 유추해봤을 때 2차원 배열이 정답일 거 같았다.

하지만 이 문제의 핵심은 경찰차의 위치가 임의의 좌표가 아니라는 점이다.  
어떤 경찰자가 특정 시점에 멈춰있다면, 그 위치는 반드시 <strong>'시작점(1,1) or (n,n)'</strong>이거나 <strong>이전에 처리했던 어떤 사건의 발생 좌표</strong> 중 하나일 것이다.

즉, 경찰차1이 $$(r,c)$$에 있다는 정보 대신,
<strong>"경찰차1이 마지막으로 처리한 사건이 a번째 사건이다"</strong>라는 정보만 있다면
$$ (r,c) $$는 `arr[a]`를 통해서 상수 시간 내에 알아낼 수 있다.

따라서 dp 테이블의 인덱스를 좌표가 아닌 **사건의 인덱스**로 바꿔야 했다.  

> `dp[i][j]`: 경찰차1이 해결한 마지막 사건이 $$i$$이고, 경찰차2가 해결한 마지막 사건이 $$j$$일 경우 최소 거리 합

이렇게 2차원 배열로 정의를 하면 $$1000^2(= 1,000,000)$$로 아주 넉넉하게 시간복잡도를 준수할 수 있었다.  
그 후에 중요한 것은 반복문의 순환 로직이었다. 단순히 $$i,j$$로 백 만번을 점화식으로 순회한다면 안 될 것이다.  
이 문제에선 **사건의 순서대로** 거리를 누적시켜 반영해야 하기 때문에 $$i,j$$의 반복문에서 **다음 사건**에 대한 점화식을 세우는 게 중요했다.
그리고 이는 $$max(i,j) + 1$$로 쉽게 정의할 수 있다.

마지막으로 $$i,j$$일 때의 거리의 합을 바탕으로 다음 사건을 1번 경찰차가 맡을 때와 2번 경찰차가 맡을 때를 구분해서 다음 값에 넘겨주는 방식이므로
**Push DP**의 점화식으로 구현하면 될 것이다.

또한 이 문제에서는 특이하게도 **사건을 맡은 경찰차의 번호**를 순서대로 출력하는 요구사항이 존재했다. 즉 **추적**을 하는 배열도 필요했었다.
이는 dp 반복문에서 Push DP를 수행할 때 다음 위치에 현재 기반의 값을 더한다는 걸 이용해서 **trace**라는 2차원 배열에 마찬가지로 **사건의 인덱스**를 저장하도록 정의했다.

> `trace[i][j]`: 경찰차1이 i, 경찰차2가 j를 마지막으로 해결했을 때, 이전 사건의 구성 번호$$(= pre_i,pre_j)$$

이렇게 정의를 하면 앞서 설명한 것처럼 $$pre_i,pre_j$$에서 넘어온 $$i,j$$를 비교할 때 $$i$$가 증가했다면 1번이 맡은 것이고, $$j$$가 증가했다면 2번이 맡은 걸
알 수 있으므로 **역추적**을 통해 사건 담당자를 알 수 있다.

### 정답 코드
```python
# 경찰차 1은 (1,1), 2는 (n,n)에서 시작
# 연락받은 경찰차는 최단 거리로 이동하고, 거기서 대기
# 사건 발생 순서대로 경찰차에게 맡김. 두 경찰차의 이동 거리의 최솟값을 구하기
from sys import stdin as input
n = int(input.readline())
t = int(input.readline())
p1 = [(1,1)]
p2 = [(n,n)]
# 1-based
for _ in range(t):
    r,c = map(int,input.readline().split())
    p1.append((r,c))
    p2.append((r,c))
# dp[i][j] = 경찰차1이 맡은 마지막 사건이 i번이고, 경찰차2가 맡은 마지막 사건이 j번일 경우 최소 거리의 합
dp = [[float('inf')] * (t+1) for _ in range(t+1)]
dp[0][0] = 0

# 추적용 배열 = (i,j)에 오기전 (pre_i,pre_j)를 저장
trace = [[None] * (t+1) for _ in range(t+1)]

for i in range(t):
    for j in range(t):
        # 다음 사건은 i,j 중 더 큰 거 + 1
        nxt = max(i,j) + 1
        # 경찰차 1
        cr,cc = p1[i]
        nr,nc = p1[nxt]
        # 경찰차 1이 nxt번을 맡으려면 i,j에서 옮겨와야 함
        d1 = abs(cr - nr) + abs(cc - nc)
        if d1 + dp[i][j] < dp[nxt][j]:
            # nxt번에 대한 trace 추가
            trace[nxt][j] = (i,j)
            dp[nxt][j] = d1 + dp[i][j]
        # 경찰차 2
        cr,cc = p2[j]
        d2 = abs(cr - nr) + abs(cc - nc)
        if d2 + dp[i][j] < dp[i][nxt]:
            trace[i][nxt] = (i,j)
            dp[i][nxt] = d2 + dp[i][j]
ans = float('inf')
end_i,end_j = -1,-1
for i in range(t):
    if ans > dp[t][i]:
        end_i,end_j = t,i
        ans = dp[t][i]
    if ans > dp[i][t]:
        end_i,end_j = i,t
        ans = dp[i][t]
print(ans)

# end_i,end_j로부터 타고 올라가기
path = []
while True:
    if end_i == 0 and end_j == 0: break
    pre_i,pre_j = trace[end_i][end_j]
    # j가 증가했다 => 2번
    if pre_j < end_j:
        path.append(2)
    # 아니면 1번
    else:
        path.append(1)
    end_i,end_j = pre_i,pre_j

for p in path[::-1]:
    print(p)
```

### 후기
또 이전과는 색다르게 dp 테이블의 정의하는 문제였었다. 단순히 **좌표**를 기반으로 테이블을 정의하는 것이 아니라 문제를 잘 읽고
좌표는 어차피 확정된 경우의 수로 알아낼 수 있기 때문에 **사건의 인덱스**를 기반으로 테이블을 정의하는 것이 훨씬 효율적인 시간복잡도를
가질 수 있게 된다는 걸 배운 문제였다. 역시 문제에 대해서 깊은 이해도를 갖춰야 하는 게 기본이거늘.. 쉽지 않다!

또한 **역추적**의 방식도 이 문제를 통해서 배울 수 있어서, 여러모로 알차고 훌륭한 문제였다고 생각한다!