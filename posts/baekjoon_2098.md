---
title: "백준 2098번 외판원 순회 (python)"
date: "2025-12-02 05:43:29"
category: "코테"
description: "python으로 풀어보는 백준 2098"
---

## 코딩 테스트 풀이

!["문제사진"](/images/2098.png)
<a href="https://www.acmicpc.net/problem/2098" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 2098번 문제 풀이에 대한 해설.

### 나의 접근
가장 처음에는 단순히 순열을 통해 완전 탐색으로 문제를 해결하려고 했었다.  
하지만 16!을 어마어마하게 큰 수이므로 1초라는 시간에 통과하기엔 절대 불가능했다.  
따라서 새로운 접근 방식을 찾았어야 했는데, 이에 저번에 풀이했던 <a href="https://vorschlag-blog.vercel.app/posts/baekjoon1562" style="color: #2f9e44; text-decoration: none;">
  계단 수
</a>에서 사용했던 비트마스킹이 생각이 났다. 이 문제도 dp의 메모리얼 기능을 사용해서 중복 계산을 최소화하고, 그 대신 중간 상태를 기록할 필요가 있어서
비트마스킹을 통해 상태 기록을 수행하고자 했다.

#### 비대칭인 비용 그래프 순회에 대해서
이 문제에서 중요한 점 중 하나는 <strong>순환(Cycle)</strong>을 찾는 문제이기 때문에 어느 지점을 출발점으로 해도 상관이 없다는 점이다.  
분명 이 문제의 조건에선 비용이 비대칭인 그래프를 순회하는 건데 어떻게 이게 가능한 건지 직관적으로는 와닿지 않을 수 있으니 아래의 예제를 살펴보자.

**1. 상황 설정(비대칭 비용)**  
도시 3개(A,B,C)가 존재하고 이동 비용이 비대칭이다.  
어떤 **최적의 경로는** $$ A -> B -> C -> A $$라고 가정하자.  
각 간선의 비용은 다음과 같다.  
- 1. $$ A -> B $$ (비용: 10)
- 2. $$ B -> C $$ (비용: 20)
- 3. $$ C -> A $$ (비용: 5)

**2. 시작점 바꿔보기**
이제 출발점을 B나 C로 할 경우를 생각해보자. 출발지만 바뀔 뿐 **이동 순서**는 그대로 유지된다는 게 중요하다.  
- 1. B에서 출발할 때: $$ B -> C -> A -> B $$ (비용: 35)
- 2. C에서 출발할 때: $$ C -> A -> B -> C $$ (비용: 35)

결론적으로 덧셈의 순서만 다를 뿐 총 비용은 고정된 걸 알 수 있다.

따라서 이 문제에서도 마찬가지로 출발지는 어느 것으로 하던 상관이 없기 때문에 편의상 0번(1번) 도시를 시작점으로 잡았다.  
dp배열 정의는 $$ dp[i][j] = i도시를 방문 할 때 j비트인 최소 순회 비용 $$라고 두었다. 
dp배열의 초기값을 `float('inf')`로 초기화했다.
이 문제는 비트마스킹이기 때문에 현재의 값이 미래에 미치는 영향을 생각하는 **Push Dp** 방식으로 점화식을 세워야 했다.

먼저, 3개의 반복문을 돌면서 bit, 출발지, 목적지에 대한 값을 누적시키면 됐는데, 문제의 요구사항을 잘 준수하게 구현하는 게 중요했었다.  
먼저 반복문의 순서의 경우 bit를 가장 바깥 반복문에 둠으로써 가장 작은 비트(최소 방문) -> 가장 큰 비트(모든 방문)방식을 지키면서  
dp의 가장 중요한 특징인 **작은 문제로 큰 문제 해결하기**의 특징을 지켰다.

그 후엔 조건문을 통해서 bit, 출발지, 목적지의 관계에 대해서 올바른 논리를 갖추도록 설계했다.  
먼저 **bit와 출발지**와의 관계에 대해서 먼저 생각을 해보자.  
bit가 먼저 반복문을 순회하기 때문에 특정 출발지에 대해서 해당 bit가 포함하고 있지 않다면 안 된다. 또한 초기값을 `float('inf')`로
했기 때문에 `dp[i][bit]`가 해당 값이라면 아직 도달할 수 없는 값에 대한 연산이므로 건너뛰어야 한다.
```python
# 아직 도달할 수 없는 값이면 pass
if dp[i][bit] == float('inf'): continue
# bit에 출발지가 포함되어 있지 않다면 pass
if bit & (1 << i) == 0: continue
```

다음으로는 **bit,출발지,도착지**의 관계에 대해서 생각해보자.  
문제에서 주어진 것처럼 같은 도시(i -> i)가 아닌데 비용이 0인 경우는 도달할 수 없는 상태이므로 건너뛰어야 한다.  
또한 이미 방문한 도시에 대해서 재방문은 금지해야 한다.(마지막 도시 제외)
```python
# (1 -> 1) 같은 경우가 아닌데 비용이 0이면 pass
if i != j and cost[i][j] == 0: continue
# 재방문 금지
if bit & (1 << j) == 1: continue
```

마지막으로 정답을 게산할 때(최솟값 찾기) 출발지에 대한 재방문 비용을 더한 상태로 계산을 해주면 된다.(앞서 재방문 금지로 출발지도 재방문 안 됌)
다만 이 때도, $$ i -> j $$의 비용이 0인 것은 pass해야 한다.
```python
for i in range(n):
  if cost[i][start] == 0: continue
  total = dp[i][2**n-1] + cost[i][start]
  ans = min(ans, total)
```

### 정답코드
```python
from sys import stdin as input

n = int(input.readline())

# 1 ~ N번까지의 도시가 있고, 한 도시에서 출발해 모든 도시를 중복없이 방문하고 다시 처음 도시로 돌아오는 경우의 수
# w[i][j] = i -> j의 비용(i -> j와 j -> i는 다를 수 있음, i -> i는 항상 0, i -> j가 불가능한 경우 비용은 0)

cost = []

for _ in range(n):
    cost.append(list(map(int,input.readline().split())))

b = 2**n
# 비트마스킹으로 지금까지 방문한 도시들을 체크해야 함
# dp[i][j] = i도시에 j 비트 상황으로 방문했을 때 경우의 수
dp = [[float('inf')] * b for _ in range(n)]

# 0에서 출발하는 비용
dp[0][1] = 0

ans = float('inf')
# 가장 적은 방문 도시 상태 -> 가장 많은 도시 방문 상태로 
for bit in range(1,2**n):
    for i in range(n):
        # dp[i][bit] = inf면 pass (아직 도달할 수 없는 상태에서 시작 불가)
        # 현재 방문한 도시 i가 비트에 포함되어 있어야 함
        if bit & (1 << i) == 0: continue
        if dp[i][bit] == float('inf'): continue
        for j in range(n):
            # i -> j의 비용이 0이면 pass
            if i != j and cost[i][j] == 0: continue
            # 다시 방문한 도시 재방문 불가
            if bit & (1 << j): continue
            # 다음 여행의 총 비용
            c = dp[i][bit] + cost[i][j]
            # 다음 여행지 포함한 비트
            nxt = bit | (1 << j)
            if dp[j][nxt] > c:
                dp[j][nxt] = c

for i in range(n):
      # 다시 0으로 돌아가는 비용이 0이면 pass
      if cost[i][0] == 0: continue
      total = dp[i][b-1] + cost[i][0]
      ans = min(ans, total)

print(ans)
```

### 후기
`&` 연산자로 논리적인 비트 연산을 수행해야 한다는 점이 좀 복잡했던 문제였다.  
문제의 요구사항을 올바르게 해석하는 것도 중요하지만, 비트마스킹 자체에 대한 이해도도 높아야 수월히 풀 수 있었을 거 같다.  
더 많은 비트마스킹 문제를 풀면서 문제를 해석하고 구현하는 능력을 길러야겠다.