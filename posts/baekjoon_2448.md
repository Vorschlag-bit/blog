---
title: "백준 2448번 별찍기 - 11 (python)"
date: "2025-12-16 17:26:42"
category: "코테"
description: "python으로 풀어보는 백준 2448"
---

## 코딩 테스트 풀이

!["문제사진"](/images/2448.png)
<a href="https://www.acmicpc.net/problem/2448" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 2448번 문제 풀이에 대한 해설.

### 나의 접근
규칙을 찾는 데에 생각보다 오랜 시간이 걸렸다.  
$$N$$은 항상 $$ 3 × 2^k\ (0<=\ k\ <= 10) $$인 수이므로, 예제 결과 속 k와 3의 상관관계를 유추해보면
3개의 삼각형(3)의 높이(이하 level)가 곧 k가 된다. (지수이므로 0-based)

그리곤 삼각형은 level 단위로 항상 3개의 삼각형으로 나눠진다. (맨위/왼/오른)  
따라서 <b>재귀(Recursion)</b>을 통해서 `level == 0`이 되기 전까지 <b>위/왼/오른</b>으로 level - 1과 적절한 
위치들을 제공해주면 될 거라고 생각했다.

하지만 별찍기를 해본 적이 거의 없어서 그냥 순수하게 위치를 계산해서 찍으면 너무 어려울 거 같아, 2차원 배열에 할당해서
<b>행/열</b>좌표를 편하게 계산하고 싶었는데, k가 10인 경우 행렬이 대략 3000 * 5000이라 혹시 메모리 초과가 나오면 어떡하지라는 고민이 있었는데, 이 부분만 AI에게 물어보니 그 정도면 수십 MB라서 아주 넉넉하다는 말을 들을 수 있었고 덕분에 맘 편히 2차원 배열을
사용했다.

재귀 함수를 구현하면서 생각보다 헷갈리는 점이 있었는데, 중앙/왼/오른의 꼭짓점 좌표를 상대적으로 계산해줘야 한다는 점이었다.

처음에는 맨 위는 그대로, <b>왼쪽은 (중앙 // 2), 오른쪽은 (중앙 + 왼쪽)</b>으로 계산을 했는데 이는 가장 큰 삼각형 3개에서만 해당되는
좌표였다.  
이게 무슨 소리인고 하니 params로 넘겨받은 r,c는 항상 상위 레벨의 맨 위를 기준으로 물려받은 것이고 이는 결국
최상단의 r,c인데 이를 바탕으로 왼/오른을 계산하면  
<b>항상 가장 큰 왼/오른 삼각형의 맨 위</b>가 되기 때문에 상대적인 위치로
수정해주기 위해 현재 level - 1의 가로,세로 길이를 바탕으로 계산하는 방식을 사용했다.

또한 배열은 보통 0-based이기 때문에 길이와의 혼동이 있을 것을 고려해서 <b>1-based</b> 배열을 사용했고,
마지막에 `[1:]`을 통해서 행과 열 모두 1부터 출력하게 함으로써 정답엔 지장이 없도록 했다.

### 정답 코드
```python
n = int(input())
# 3 * 2**k = k가 몇 인지 알면, 2**k 27개짜리 피라미드 콘솔에 출력
n //= 3
k = 0
while 2**k < n:
    k += 1
# 가운데가 빈 삼각형 만들기
# 가로
c = 5
r = 3
cnt = 0
while cnt < k:
    c = c * 2 + 1
    r *= 2
    cnt += 1
# 세로
arr = [[' '] * (c+1) for _ in range(r+1)]
# 0 = 3, 1 = 6, 2 = 12
start = 3 * (2**k)
# 재귀를 통해서 가장 작은 삼각형을 찍을 수 있을 때까지 쪼개기
def triangle(r,c,level,x,y):
    global arr
    # level이 0이면 point를 기준으로 가장 작은 삼각형 찍기
    if level == 0:
        # 꼭짓점
        arr[r][c] = '*'
        # 바로 아래 2개
        arr[r+1][c-1],arr[r+1][c+1] = '*', '*'
        # 그 아래 5개
        for i in range(5):
            arr[r+2][c-2+i] = '*'
        return
    
    # 그게 아니면 level - 1한 상태로 꼭/왼/오른 재귀
    ex_y = ((y-1) // 2)
    # 12, ex_y = 11 // 2 = 5
    ex_x = x // 2
    # 12 가로, level = 1 기준, 
    # r = 행, c = 열
    triangle(r,c,level-1,ex_x,ex_y)
    triangle(r+ex_x,c-ex_y//2-1,level-1,ex_x,ex_y)
    triangle(r+ex_x,c+ex_y//2+1,level-1,ex_x,ex_y)

triangle(1,start,k,r,c)

for row in arr[1:]:
    print(''.join(row[1:]))
```
