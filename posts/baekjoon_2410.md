---
title: "백준 2410번 2의 멱수의 합 (python)"
date: "2025-12-11 13:51:56"
category: "코테"
description: "python으로 풀어보는 백준 2410"
---

## 코딩 테스트 풀이

!["문제사진"](/images/2410.png)
<a href="https://www.acmicpc.net/problem/2410" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 2410번 문제 풀이에 대한 해설.


### 나의 접근
처음에는 특정 수 $$n$$에 대해서 n에 마지막으로 들어갈 수를 기준으로 $$2^m <= n$$를 만족하도록
$$ dp[n] = dp[n] + dp[n - 2^m] $$이라는 점화식을 세워서 풀어보려고 했었다.

시간복잡도가 $$NlogN$$이므로 2초라는 시간을 충분하게 계산할 수 있을 거라고 생각했기 때문이다.(N은 최대 100만)  
하지만 이렇게 풀고, 디버깅을 해보니 이건 **순열**의 방식이었다.

#### 잘못된 풀이(순열)
```python
from sys import stdin as input

n = int(input.readline())

dp = [0] * (n+1)
dp[0] = 1
for i in range(1,n+1):
    cur = 0
    while 2**cur <= i:
        dp[i] += dp[i-2**cur]
        cur += 1
print(dp[n]%1000000000)
```

이 점화식으로 반복문을 돌게 되면 <strong>숫자 1부터 N까지 채워나갈 때 마지막에 더한 숫자가 무엇인지</strong>를 기준으로 경우의 수가 누적되기 때문에,
$$2 + 1$$과 $$1 + 2$$를 다르게 본다. 

하지만 이 문제는 **조합**에 대한 정답을 원한다. 따라서 나는 관점을 다르게 볼 필요가 있었다. **특정 숫자 N을 기준으로 삼을 게 아니라 2의 멱수 자체를 기준**으로
삼으면 순열에서 조합의 DP로 바뀌게 된다.

무슨 말인고 하니, $$ 2^0 ~ 2^m(2^m <= N) $$을 만족하도록 $$1(2^0)$$부터 $$2^m$$의 반복문을 돌면서 $$logN * M$$의 시간복잡도로 풀이하는 것이다.

반복문을 짤 때 N부터 내려가면서 경우의 수를 쌓아야할지, 아니면 해당 2의 멱수부터 올라가면서 경우의 쌓아야할지가 헷갈릴 수 있다.

그럴 땐 해당 수가 여러 번 사용될 수 있는지를 생각해보자. 
2라는 값을 예로 들면, 특정의 N에 대한 조합을 만들 때 2를 한 번만 사용할 수 있다면 N -> 2로 출발하고 2를 여러 번 사용한 조합을 만들 수 있다면
2 -> N으로 올라가면서 쌓으면 된다.

### 정답 코드
```python
from sys import stdin as input

n = int(input.readline())

dp = [0] * (n+1)
dp[0] = 1
i = 0
while 2**i <= n:
    # 2의 멱수(1,2,4...)
    cur = 2**i
    # cur로 만들 수 있는 모든 경우의 수 더해주기
    for j in range(cur,n+1):
        dp[j] += dp[j-cur]
    i += 1

print(dp[n] % 1000000000)
```