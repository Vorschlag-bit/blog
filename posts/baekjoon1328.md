---
title: "백준 1328번 고층 빌딩 (python)"
date: "2025-11-28 06:16:08"
category: "코테"
description: "python으로 풀어보는 백준 1328"
---

## 코딩 테스트 풀이

!["문제사진"](/images/1328.png)
<a href="https://www.acmicpc.net/problem/1328" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 1328번 문제 풀이에 대한 해설.

### 나의 접근
먼저 문제를 봤을 때, <a href="https://vorschlag-blog.vercel.app/posts/baekjoon2302" style="color: #2f9e44; text-decoration: none;">
  극장 좌석
</a>이 생각이 났었다. 가장 왼쪽에서 빌딩을 봤을 때 <strong>가장 높은 건물</strong>을 기준으로 
<strong>l</strong>개가 보이려면 왼쪽에 오름차순 l개의 조합 * l!(순열) * 오른쪽에 그 나머지 수들의 순열((n-l)!)을
배치하면 될 거 같았기 때문이다.

하지만 오름차순의 조합 배열을 구하는 과정이 너무 복잡해질 거 같아서, 이런 접근은 아니라고 생각했고
AI에게 이 문제에 대한 접근 방식을 물어봤었다.

결론적으로 이 문제는 <strong>조합론(스털링 수)</strong>을 사용하거나 **dp**를 통해서 푸는 문제였었다.
이 문제를 **극장 좌석**처럼 단순히 왼쪽에 k를 주자라고 생각하면 어떤 숫자를 주느냐에 따라 누가 가려지는지 일일이 따져야하는 문제가 있다.  이 문제를 해결하기 위해선 발상의 전환이 필요하다. **보이는 건물 1개와 그 뒤에 숨은 건물들**을 묶어서
하나의 그룹으로 취급하는 것이다. 즉 우리는 가장 큰 건물을 기준으로 왼쪽에는 **l-1**개의 그룹을 오른쪽으로는 **r-1**개의 그룹을
갖추면 왼쪽, 오른쪽에서 볼 때 l,r개의 건물을 볼 수 있을 것이다. (n-1 개를 l+r-2개의 그룹으로 나눠야 한다.)  
좀 더 직관적인 이해를 위해 그림을 준비했다.

!["그림예시"](/images/1328_1.png)

위 그림은 `n = 100`인 환경에서 l = 3인 기준을 예시로 든 그림이다. 왼쪽에서 3개의 건물이 보여야하기 때문에
가장 큰 건물은 100을 제외하고 2개의 건물을 뽑아야 할 것이다. 하지만 그게 단순히 하나의 건물이 아닌 **가장 높은 건물과 그 뒤에 숨은 건물들**이라는 그룹으로 취급하는 것이다. 그림처럼 사실 2개의 소그룹으로 이뤄져 있으나 왼쪽에서 바라볼 때는 단순히 3개의 건물만 보일 것이다.

N - 1개의 원소를 갖고서 순서가 있는 K개의 그룹을 만드는 것은 N - 1개의 원소로 K개의 원탁으로 나누는 경우의 수와 일치한다. <strong>(제 1종 스털링의 수)</strong>

#### 왜 원탁인가?
건물 3개 <strong>{5,4,3}</strong>을 팀을 만든다고 할 때 가장 높이가 큰 5가 앞에 와야 하므로  
**5-4-3**, **5-3-4** 이렇게 2가지의 수가 존재하고 이는 곧 <strong>(3-1)!</strong>(=2)과 일치하기 때문이다.  
즉, 건물 k를 골라서 1개만 보이는 팀을 만드는 경우의 수는 아래와 같다.  
$$ 경우의 수 = 1 * (k-1)! $$  

n-1개로 l+r-2개의 그룹을 나눈 뒤에는 팀을 좌우로 어떻게 배치할지 결정하면 된다.(조합)  
이 중에서 누가 **왼쪽**에 서고 누가 **오른쪽**에 설지 결정하는 방법은 그룹에서 **l-1**개를 고르기만 하면 된다.  
l-1개를 고르면 반드시 오름차순으로 배치가 되어야 할 것이고(경우의 수 1개) 오른쪽 역시 남은 그룹들로 자동으로 순서가 결정된다.

#### 조합론 풀이 요약 
1.  **팀 만들기**: 남은 $N-1$개로 전체 필요한 팀($L+R-2$)을 다 만든다.
    $$ \left[ \begin{smallmatrix} N-1 \\ L+R-2 \end{smallmatrix} \right] $$
2.  **팀 나누기**: 만든 팀 중에서 왼쪽에 설 $L-1$개를 고른다.
    $$ \binom{L+R-2}{L-1} $$

$$ \therefore \text{정답} = \left[ \begin{smallmatrix} N-1 \\ L+R-2 \end{smallmatrix} \right] \times \binom{L+R-2}{L-1} $$

제1종 스털링의 수 점화식은 아래와 같다.  
$$ S[i][j] = S[i-1][j-1] + (i-1) * S[i-1][j] $$  
<strong>i명의 사람을 j개의 원탁(순환 그룹)에 앉히는 경우의 수</strong>에서 가장 마지막 i번째 사람이 앉는 방법은
2가지이다.

- 1. 혼자서 새로운 테이블에 앉기: 이렇게 앉으려면 이전 i-1명은 j-1개의 테이블에 앉아있어야하고 한다.(= S[i-1][j-1])  
- 2. 기존 그룹에 끼기: 이미 사람이 있는 테이블에 끼려면 i-1명은 j개의 테이블에 앉아있고, i-1명의 오른쪽에 앉을 수 있으므로 i-1개의 공간이 존재한다(= S[i-1][j] * (i-1))

#### 점화식 최종 결론
$$ S[i][j] = \underbrace{S[i-1][j-1]}_{\text{1. 혼자 새 그룹 만들기}} + \underbrace{(i-1) \times S[i-1][j]}_{\text{2. 기존 사람 수만큼 존재하는 틈에 끼어들기}} $$

### 정답 코드(조합론)
```python
# 1. 제1종 스털링 수 테이블 만들기
# S[n][k]: n개의 원소를 k개의 순환 그룹으로 나누는 경우의 수
S = [[0] * (n + 1) for _ in range(n + 1)]
S[0][0] = 1

for i in range(1, n + 1):
    for j in range(1, i + 1):
        # 점화식: S[i-1][j-1] + (i-1)*S[i-1][j]
        S[i][j] = (S[i-1][j-1] + (i-1) * S[i-1][j]) % 1000000007

# 2. 조합(Combination) 계산 함수
def nCr(n, r):
    # (생략: 팩토리얼 등을 이용해 계산)
    pass

# 3. 정답 계산
# 전체 그룹 개수 K = (L-1) + (R-1)
K = (l - 1) + (r - 1)

if K > n - 1:
    print(0)
else:
    # (N-1)개의 건물을 K개 그룹으로 나누기 * K개 중 왼쪽 L-1개 고르기
    ans = (S[n-1][K] * nCr(K, l-1)) % 1000000007
    print(ans)
```

### dp로 풀어보기
조합론으로 푸는 건 현학적이고 **스털링 수**라는 마이너한 개념에 대해서 알고 있어야하는 등 실제 코테에서 
내가 이런 방식으로 풀 수 있을까라는 생각했을 때 그렇지 않을 거라고 생각했다.

이 문제는 조합론 말고도 **dp**로도 풀이할 수 있는데 그 과정에 대해서 짧게 이야기해보자.  
먼저 dp 배열은  
$$ dp[i][j][k] = i개의 건물을 왼쪽에서 j개, 오른쪽에서 k개 볼 수 있는 경우의 수 $$  
라고 가정한다.  
그 후엔 앞서 조합론과 비슷한 사고를 거치면 된다. i개의 건물 중 가장 작은 건물이 배치될 수 있는 가능성을 따진다.

- 1. 가장 왼쪽: 가장 작은 건물을 왼쪽에 배치한다면 왼쪽에는 + 1 오른쪽에는 영향을 주지 않을 것이다.
즉 i-1개의 건물을 왼쪽에서 j-1개, 오른쪽에서 k개가 보이는 경우의 수와 같다.  
- 2. 가장 오른쪽: 왼쪽과 마찬가지로 왼쪽에는 0, 오른쪽에는 1개의 건물이 추가로 더 보일 것이다.
즉 i-1개의 건물을 왼쪽에서 j개 오른쪽에서 k-1개 보이는 경우의 수와 같다.  
- 3. 중간 어딘가: 가장 왼/오른을 제외한 나머지 모든 공간에 배치가 가능하다.
즉 i-1개의 건물이 왼쪽에선 j-1개가 보이고, 오른쪽에서 k-1개가 보이는 경우의 수에서 <strong>i-2(양쪽을 제외한 모든 자리)</strong>을 곱한 경우의 수와 같다.

#### dp 점화식 정리
$$ dp[i][j][k] = dp[i-1][j-1][k] + dp[i-1][j][k-1] + (i-2) * dp[i-1][j-1][k-1] $$  

### 정답 코드
```python
from sys import stdin as input

n,l,r = map(int,input.readline().split())

# 빌딩 높이는 1~n
# dp[i][j][k] -> i = 현재 건물의 개수, j = l에 보이는 건물 수, k = r에서 보이는 건물 수
dp = [[[0] * (r+1) for _ in range(l+1)] for _ in range(n+1)]
dp[1][1][1] = 1

# dp[i][j][k] = (dp[i-1][j-1][k] + dp[i-1][j][k-1]) * dp[i-1][j][k]
for i in range(2,n+1):
    for j in range(1,l+1):
        for k in range(1,r+1):
            dp[i][j][k] = ((dp[i-1][j-1][k] + dp[i-1][j][k-1]) + dp[i-1][j][k] * (i-2)) % 1000000007

print(dp[n][l][r])
```

### 후기
이번 문제는 조합론, 그것도 좀 마이너한 개념에 대해서 다루는 문제다보니 정말 어려웠었다.. 
실전에서 이런 문제를 만나면 못 풀 거 같은 느낌이 강하지만(물론 아직까지 이런 문제를 만나본 적은 없다) 다양한 풀이를
알고 싶은 마음으로 코테를 푸는 것이므로 학습해서 정리하게 되었다. dp의 다양한 문제를 풀면서 내가 그토록
갖고 싶은 태도인 **큰 문제 작게 쪼개기**에 다가가는 과정이라고 생각한다.