---
title: "백준 20040번 사이클 게임 (python)"
date: "2025-12-30 14:15:32"
category: "코테"
description: "python으로 풀어보는 백준 20040"
---

## 코딩 테스트 풀이

!["문제사진"](/images/20040.png)
<a href="https://www.acmicpc.net/problem/20040" class="plink">
  문제링크
</a>

백준 20040번 문제 풀이에 대한 해설.

### 나의 접근
처음에는 가장 중요한 조건인 'C에 속한 임의의 선분의 한 끝점에서 출발하여 모든 선분을 한 번씩만 지나서 출발점으로 되돌아올 수 있다.'에 대해서 생각해보면 결국 '방향성'을 갖는 사이클을 끝까지 유지할 수 있냐를 판단해야 할 거 같았다.

하지만 예를 들어 예제 1번과 같은 입력이 주어질 경우, $0 - 1 - 2 - 3$이라는 방향성을 갖춘 그래프가 만들어지고, $0-4-5$라는 그래프도 만들어진다.  
이런 그래프를 만드려면, 0 1을 입력받을 때 1이라는 노드에 대한 기존 그래프가 있는지를 판단해야 하는데 그런 그래프가 여러 개일 경우엔 매우 복잡한 로직이
될 것이었다.

따라서 내가 기존에 아는 그래프 탐색으로는 풀 수 있는 문제가 아니라고 판단, 카테고리 분류를 보니 <b>분리 집합</b>에 대한 문제였다.

분리 집합이란 특정 노드끼리 연결할 때 기존에 있는 그래프였는지를 확인하고, 아닐 경우 하나의 그래프로 만드는 알고리즘이다.

분리 집합의 구현은 생성되는 그래프를 대표할 노드를 통해 서로 같은 대표 노드를 갖고 있다면 같은 그래프에 소속된 걸 파악하는 게 핵심이다.
따라서 대표 노드를 파악하는 재귀 함수와 서로 다른 그래프 소속이라면 연결시켜주는 함수가 있어야 한다.

연결시키는 함수에서 가장 중요한 것은 <b>대표 노드</b>를 다른 대표 노드의 밑으로 연결시켜줘야 그 이하의 노드들이 한꺼번에 이동된다는 것이다.

알고리즘을 쉽게 설명하기 위한 예제로 (`0-1`,`1-2`,`0-2`)라는 입력이 주어졌다고 가정해보자. 그래프 판별은 아래의 로직에 따라 이뤄진다.

1.  **`0-1` 연결:**
    *   0번의 대표 $\to$ 0
    *   1번의 대표 $\to$ 1
    *   대표가 다르다? 합체! (이제 0, 1은 같은 팀)
2.  **`1-2` 연결:**
    *   1번의 대표 $\to$ 0 (아까 합쳐져서)
    *   2번의 대표 $\to$ 2
    *   대표가 다르다? 합체! (이제 0, 1, 2는 모두 대표 0 아래의 같은 팀)
3.  **`0-2` 연결 (중요!):**
    *   0번의 대표 $\to$ 0
    *   2번의 대표 $\to$ 0
    *   **서로의 대표가 같음을 인지 (이미 연결되어 있음을 파악)**
    *   **여기서 사이클 완성**

### 정답 코드
```python
from sys import stdin as input

n,m = map(int,input.readline().split())

p = [i for i in range(n)]

def find(num):
    if p[num] == num: return num

    # 경로 압축
    p[num] = find(p[num])
    return p[num]

def union(a,b):
    r_a = find(a)
    r_b = find(b)

    if r_a != r_b:
        if r_a < r_b:
            p[r_b] = r_a
        else :
            p[r_a] = r_b
        return True
    else: return False

for t in range(m):
    a,b = map(int,input.readline().split())
    if find(a) == find(b):
        print(t+1)
        exit()
    union(a,b)
print(0)
```
