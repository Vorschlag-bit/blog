---
title: "백준 2473번 세 용액 (python)"
date: "2026-01-04 16:58:14"
category: "코테"
description: "python으로 풀어보는 백준 2473"
---

## 코딩 테스트 풀이

!["문제사진"](/images/2473.png)
<a href="https://www.acmicpc.net/problem/2473" class="plink">
  문제링크
</a>

백준 2473번 문제 풀이에 대한 해설.

### 나의 접근
이전에 풀었던 <a href="https://vorschlag-blog.vercel.app/posts/baekjoon_2467" class="plink">
  용액
</a>문제의 후신이다. '용액' 문제와 거의 똑같지만 이번엔 3개의 용액을 대상으로 합이 0에 가장 가까운 용액 3가지를 출력하는 것.

용액 문제를 풀어봤다면 이 문제는 <b>투 포인터</b>와 <b>이진 탐색</b> 두 가지를 통해 풀 수 있다는 걸 알 수 있다.
거기서 조금만 더 생각을 해보면 되는 문제였다.

먼저 특정 용액 $m$에 대해서 남은 두 용액의 합이 $-m$에 가장 가깝도록 구성을 하면 된다.  
즉, $-m$에 대한 투 포인터를 시도하면 된다. 사실상 <b>조합</b>을 찾는 문제이기 때문에 최적의 탐색을 시도하면 된다.

정렬된 배열에서 $m$을 순서대로 순회하고 $-m$을 위한 투 포인터의 시작점으로 l을 $m$의 인덱스인 $i$보다 1만큼 크게 해서
중복된 탐색을 최대한 줄이면 시간 복잡도를 더 좋게 가져갈 수 있다.

투 포인터는 $l$과 $r$이 같은 방향으로 나아가는 슬라이딩 윈도우가 아니라 양 쪽에서 좁혀 줄여가는 방식이다, 기존의 값과 
비교 후 작을 경우엔 음수의 포인터인 $l$에 1을 더하고 클 경우엔 양수의 포인터인 $r$에 1을 빼는 식으로 탐색하면 된다.

이러한 방식으로 구현하면 시간 복잡도는 $O(N^2)$이므로 5000이라는 최댓값일 경우, 2500만번의 연산이면 답을 찾을 수 있으므로
1초라는 시간 안에 충분히 통과할 수 있다.

다만 python3의 반복문에 대한 오버헤드는 매우 큰 편이라 1초에 1000만에서 2000만 사이의 연산을 안정적으로 수행하기 때문에 2500만번인
이 문제는 시간초과가 날 수밖에 없으므로 <b>pypy3</b>로 제출해야 통과할 수 있다.

### 정답 코드 (pypy3로만 통과 가능)
```python
from sys import stdin as input

# 세 가지 용액의 합이 0에 가장 가까운 수를 출력
n = int(input.readline())
arr = list(map(int,input.readline().split()))

# 특정 수 m에 대한 최적의 수는 -m
# 나머지 두 수의 합이 -m을 만족할 수 있는 최적의 수를 찾아야 함...
# 5000 * 5000 = 2천5백만

arr.sort()
# 정답은 1. -m에 최대한 가까워야 함. 2. -m + m이 0에 가까워야 함
ans = float('inf')
a,b,c = 0,0,0
for i,m in enumerate(arr):
    t = -m
    l = i+1
    r= n-1
    while r > l:
        s = arr[r] + arr[l]
        if ans > abs(arr[i] + arr[r] + arr[l]):
            ans = abs(arr[i] + arr[r] + arr[l])
            a,b,c = i,l,r
        # 목표한 것보다 크다면 r을 줄이기
        if s > t: r -= 1
        # 목표한 것보다 작다면 l을 늘리기
        else: l += 1
ans_l = sorted([arr[a],arr[b],arr[c]])
print(' '.join(map(str,ans_l)))
```
