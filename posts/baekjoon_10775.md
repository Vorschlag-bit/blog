---
title: "백준 10775번 공항 (python)"
date: "2026-01-19 19:47:16"
category: "코테"
description: "python으로 풀어보는 백준 10775"
---

## 코딩 테스트 풀이

!["문제사진"](/images/10775.png)
<a href="https://www.acmicpc.net/problem/10775" class="plink">
  문제링크
</a>

백준 10775번 문제 풀이에 대한 해설.

### 나의 접근
문제가 잘 이해가 안 가서 LLM에게 이해 좀 시켜달라고 물어봤던 문제였다.

요지는 입력받은 게이트 번호 $Gi$에 대해서 <b>해당 비행기는 1번부터 $Gi$까지 모든 게이트 중 비어있는 곳을 사용할 수 있다</b>는 점이다.  

그렇게 된다면 문제의 예시인 1번의 경우 1번 게이트에 대해서 총 2번의 입력이 주어진다.
하지만 힌트에서 볼 수 있다시피 1번 게이트는 1번 하나뿐이라서 2번의 도킹이 이뤄질 수 없다.

이를 통해서 어떠한 게이트 입력이 주어질 때, 도킹을 처리하는 방법은 최대한 크게($Gi$와 가깝게) 해당 입력에 대한 게이트를 배정하는 것이다.

만약 그러다가 중복된 게이트 요청이 이뤄지면 어떻게 될까? 앞선 예제처럼 중복된 $1$이라는 게이트 요구가 발생하면 <b>해당 게이트는 이미 $Gi$는 이미 차지하고 있으니까 그 앞에 번호 중 가장 큰 수를 고르도록 수행해야 한다. ($Gi - 1$)</b> 

그렇다면 또 이런 예제를 생각해볼 수 있다. 만약 $1$부터 $10$까지의 게이트가 있고, 그 중 $3$부터 $5$는 다 차지된 상태라고 가정해보자. 이럴 경우 만약 $4$라는 입력이 주어지면 우리는 이제 해당 비행기는 무조건 $2$에 배치되어야 한다는 걸 알 수 있다.

하지만 이를 어떻게 빠르게 알 수 있을까? 이는 <b>분리 집합</b>을 사용하면 쉽게 알 수 있다.

분리 집합은 하나의 집합을 대표하는 값을 기준으로 둔 후에 특정 수에 대한 집합 포함 여부를 빠르게 판별하는 방식이다.

이렇게 말하면 이해가 잘 되질 않으니, 좀 더 이 문제를 바탕으로 설명을 해보면 앞서 $3$부터 $5$라는 게이트가 모두 차지가 되어 있다면 다음 입력으로 이 숫자들 중 하나가 입력될 경우 모두 $2$라는 값을 뱉어내야 올바른 판단을 할 수 있을 것이다.

즉 이는 이 3개의 숫자들은 모두 하나의 집합이며 그 집합을 대표하는 값이 곧 $2$라는 의미이다.

분리 집합을 만들 때는 두 집합이 서로 만났을 때가 가장 중요하다.

이 때는 대표하는 숫자끼리 비교한 후, 대표값 중 작은 값이 더 큰 값에 대한 대표가 된다. 이를 통해 두 집합은 하나로 될 수 있다.

특정 게이트(혹은 그 게이트가 속한 집합의 루트)에 비행기가 도킹에 성공했다면, 해당 게이트는 이제 <b>사용 완료</b> 상태가 된다. 따라서 이후에 또다시 이 게이트를 찾는 요청이 들어오면, 자동으로 <b>바로 그 앞번호인 $G-1$번 게이트(혹은 그 앞의 빈 게이트)</b>로 안내해줘야 한다.

이를 구현하기 위해 도킹에 성공한 게이트의 루트를 찾은 뒤, `union(root, root-1)`을 수행하여 현재 집합을 바로 왼쪽 집합에 합쳐버린다.

이렇게 하면 유니온 파인드의 <b>경로 압축(Path Compression)</b> 효과 덕분에, 중간에 꽉 찬 구간(예: $3, 4, 5$)이 있더라도 나중에 $5$번 입력이 들어오면 복잡한 탐색 없이 한 번에 빈 공간인 $2$번을 가리키게 된다.

최종적으로, 만약 `find`를 통해 찾은 루트가 $0$이라면, 이는 1번 게이트 앞인 0번, 즉 <b>더 이상 도킹할 수 있는 빈 게이트가 없다</b>는 뜻이므로 공항을 폐쇄하고 종료하면 된다.

### 정답 코드
```python
from sys import stdin as input

# 분리 집합
# 집합의 대포를 가장 큰 번호로 할지 아니면 가장 작은 번호로 해야 할지...
# -> 작은 번호가 맞는 거 같다.

g = int(input.readline())
p = int(input.readline())

arr = [i for i in range(g+1)]

def find(i):
    global arr   
    if arr[i] == i: return i

    # 경로 압축
    arr[i] = find(arr[i])
    return arr[i]

def union(a,b):
    global arr
    # a,b를 서로 연결하기
    # arr[a] = b
    r_a = find(a)
    r_b = find(b)
    if r_a != r_b:
        if r_a > r_b:
            arr[r_a] = r_b
        else: arr[r_b] = r_a

ans = 0
for _ in range(p):
    # 0-based
    i = int(input.readline())
    # 대표 번호
    root = find(i)
    if root == 0: break
    union(root, root-1)
    ans += 1
    
print(ans)
```
