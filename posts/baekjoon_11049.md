---
title: "백준 11049번 행렬의 곱셈 순서 (python)"
date: "2026-01-06 14:43:02"
category: "코테"
description: "python으로 풀어보는 백준 11049"
---

## 코딩 테스트 풀이

!["문제사진"](/images/11049.png)
<a href="https://www.acmicpc.net/problem/11049" class="plink">
  문제링크
</a>

백준 11049번 문제 풀이에 대한 해설.

### 나의 접근
행렬에 대한 이해가 있어야 했어서 상당히 어려웠던 문제였다.

먼저 이 문제가 원하는 최소 행렬 곱셈 연산의 수라는 게 무엇인지를 좀 더 자세히 알아야 한다.
문제에선 너무 단순한 예시를 들어서 이것만 가지고선 사실 푸는 게 매우 힘들다고 생각한다.

$N * M$과 $M * K$ 그리고 $K*J$라는 세 행렬을 서로 곱한다고 생각을 해보자.  
결과 행렬의 크기는 결국 첫 번째 행렬의 행과 마지막 행렬의 열을 곱한 $N*J$가 된다.  

하지만 이 내부에 들어갈 수에 대한 총 연산 횟수는 어떻게 될까?

핵심은 <b>"결합 법칙은 성립하지만, 그 과정에서 만들어지는 '임시 행렬'의 크기가 다르다"</b>는 점에 있다.  
행렬 곱셈의 비용(연산 횟수)는 다음과 같은 공식으로 결정된다.
$$
비용 = (왼쪽\ 행렬의\ 행) * (공통\ 차원) * (오른쪽\ 행렬의\ 열)
$$

세 행렬 $A(N,M),B(M,K),C(K,J)$를 곱하는 두 가지 경우를 비교해보자.  

1. $(AB)C$: <b>앞에 두 개를 먼저 곱하는 경우</b>  
- 먼저 $A$와 $B$를 곱한다. (비용: $N*M*K$, 임시 행렬($X$)의 크기: $N*K$)
- 그 후엔 위의 임시 행렬($X$)와 $C$를 곱한다. (비용: $N*K*J$, 총 비용: $(N*M*K)+(N*K*J)$)

2. $A(BC)$: <b>뒤의 두 개를 먼저 곱하는 경우</b>
- 먼저 $B$와 $C$를 곱하낟. (비용: $M*K*J$, 임시 행렬($Y$)의 크기: $M*J$)
- 그 후엔 $Y$와 $C$를 곱한다. (비용: $N*M*J$m 총 비용: $(N*M*J)+(M*K*J)$)

결론적으로, 최종 결과물은 둘 다 $N*J$ 크기의 행렬이지만, 중간에 거쳐가는 <b>임시 행렬($X,Y$)의 크기</b>가 다르기 때문에 곱셈 횟수에서 차이가 발생한다.

만약 $N,M,K,J$ 중 특정값이 매우 크다면, 그 큰 값은 <b>언제 곱셈에 참여시키는가</b>가 전체 연산량은 몇 배에서 몇 백배까지 차이가 날 수 있는 것이다.

이것이 이 문제를 단순히 순서대로 곱하는 것이 아니라 <b>구간 DP(Interval DP)</b>를 사용해서 어디서부터 끊어 곱하는 것이 효율적인지를 탐색해야 하는 이유다.

이 문제의 DP 테이블은 아래와 같다.
$$
dp[i][j] = i번째\ 행렬부터\ j번째\ 행렬까지\ 곱했을\ 때\ 최소\ 연산\ 횟수
$$
최종적으로 우리가 원하는 값은 $dp[0][n-1]$이 된다.

### 왜 Interval DP(구간 DP)인가?

일반적인 DP는 보통 $i$를 0부터 N까지 순차적으로 증가시키며 값을 채워나간다. 하지만 행렬 곱셈 문제는 단순한 선형 진행으로는 풀 수 없다.

$dp[i][j]$를 구하기 위해서는 그 내부에 포함된 **더 작은 구간들의 최솟값**이 이미 계산되어 있어야 하기 때문이다.
예를 들어, 0번부터 5번 행렬까지의 곱셈 비용($dp[0][5]$)을 알기 위해서는, 그 안을 쪼개는 모든 경우의 수(예: $dp[0][2]$와 $dp[3][5]$ 등)가 먼저 완성되어 있어야 한다.

따라서 이 문제는 $i, j$의 인덱스 순서가 아니라, <b>구간의 길이(Gap)</b>를 1부터 N까지 늘려가며 채우는 **Interval DP** 방식을 사용해야 한다.
1.  길이가 1인 모든 구간 계산 (곱셈 비용 0)
2.  길이가 2인 모든 구간 계산
3.  ...
4.  길이가 N인 전체 구간 계산

### 점화식 도출: K를 기준으로 나누기

$i$번째부터 $j$번째 행렬까지의 구간을 **$k$** 라는 지점을 기준으로 두 덩어리로 나눈다고 가정해보자. ($i \le k < j$)

이때 전체 비용은 다음 **세 가지 비용의 합**으로 구성된다.

1.  **왼쪽 덩어리 비용:** $A_i$부터 $A_k$까지 곱하는 데 드는 최소 비용 $\rightarrow$ `dp[i][k]`
2.  **오른쪽 덩어리 비용:** $A_{k+1}$부터 $A_j$까지 곱하는 데 드는 최소 비용 $\rightarrow$ `dp[k+1][j]`
3.  **합치는 비용:** 완성된 왼쪽 행렬과 오른쪽 행렬을 최종적으로 곱하는 비용

이때 <b>'합치는 비용'</b>을 코드로 표현하면 다음과 같다.
행렬의 크기를 담은 배열을 `arr`이라고 할 때,
*   왼쪽 덩어리의 행 개수 ($N$) = `arr[i][0]` (구간의 시작 행)
*   중간 공통 차원 ($M$) = `arr[k][1]` (나뉘는 지점의 열)
*   오른쪽 덩어리의 열 개수 ($K$) = `arr[j][1]` (구간의 끝 열)

따라서 점화식은 다음과 같이 정의된다.

$$
dp[i][j] = \min_{i \le k < j} (dp[i][k] + dp[k+1][j] + (\text{arr}[i][0] \times \text{arr}[k][1] \times \text{arr}[j][1]))
$$

우리는 가능한 모든 $k$에 대해 이 값을 계산하고, 그중 **최솟값**을 `dp[i][j]`에 저장하면 된다.


### 정답 코드
```python
from sys import stdin as input
n = int(input.readline())

arr = []

for _ in range(n):
    a,b = map(int,input.readline().split())
    arr.append((a,b))

# dp[i][j] = i번째 행렬부터 j번째 행렬까지 곱했을 때의 최소 연산 횟수
dp = [[0] * n for _ in range(n)]

# 작은 구간부터 큰 구간으로 interval DP하기 위한 구조
for gap in range(1,n):
    for start in range(n-gap):
        end = start + gap

        dp[start][end] = float('inf')

        for k in range(start,end):
            cost = dp[start][k] + dp[k+1][end] + (arr[start][0] * arr[k][1] * arr[end][1])
            dp[start][end] = min(dp[start][end], cost)

print(dp[0][n-1])
```
