---
title: "백준 2011번 암호코드 (python)"
date: "2025-12-01 07:25:24"
category: "코테"
description: "python으로 풀어보는 백준 2011"
---

## 코딩 테스트 풀이

!["문제사진"](/images/2011.png)
<a href="https://www.acmicpc.net/problem/2011" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 2011번 문제 풀이에 대한 해설.

이전에 선택한 값이 이후에 값을 결정하는 데에 영향을 주므로, **dp** 유형의 문제라고 생각했다.
그렇다면 **점화식**을 어떻게 세우는가만 생각하면 되는 문제.

먼저 **dp**의 특성이 자신 이전 값에 대해서만 생각하는 것을 고려해서 마지막 `dp[n]`을 기준으로 점화식을 세웠다.  
주어진 n을 문자열로 받고서, 각 자리수를 1자리 혹은 2자리로 해석하는 경우에 대한 경우의 수를 누적시키면 된다.

### 1. 현재 숫자를 1자리로 해석하기
현재 숫자인 `n[i]`가 1자리 수로 해석되기 위해선 현재 숫자의 경우의 수가 1개로 고정되므로 `dp[i-1]`의 경우의 수와 같다.  
다만 `n[i]`가 **0**일 경우에는 1자리 수로 해석되지 않으므로 0이 아닌 경우에만 dp 배열을 누적시켰다.

### 2. 현재 숫자를 2자리 수의 1의 자리로 해석하기
알파벳은 총 26개가 존재하므로, 10~26과 같이 **2자리 수**들에 대한 고려도 해야 한다.  
이는 이전 숫자 + 현재 숫자(`dp[i-1] + dp[i]`)가 10 이상 26 이하의 값을 지닐 경우에만 `dp[i-2]`의 경우의 수와 같아진다.  
또한 이 경우를 처리하기 위해서 인덱스를 `1-based`로 맞추고, `dp[0] = 1`이라는 값을 부여했다. 이렇게 함으로써 점화식에 연속성이 생기기 떄문이다.
예를 들어서 **14**라는 숫자에서 '4'를 처리하는 과정은 '1'에서 넘어온 경우의 수와 아무것도 없는 0에서 넘어온 경우의 수를 더해 줘야 한다.

### 정답 코드
```python
n = input()

# n이 주어질 때, 그 암호의 해석이 몇 가지 나올 수 있는지 출력
# 마지막 i기준, i를 1자리로 해석할 경우 (1~9)
# dp[i] += dp[i-1]
# i를 2자리로 해석이 가능할 경우 (10 ~ 26)
# dp[i] += dp[i-2]

if n == "0":
    print(0)
    exit()

n = "0" + n

dp = [0] * len(n)
dp[0] = 1

for i in range(1,len(n)):
    cur = n[i]
    pre = n[i-1]
    # 1자리로 해석(현재 자리가 0이 아녀야 함)
    if cur != "0":
        dp[i] += dp[i-1]
    # 2자리로 해석(이전 + 현재가 10 <= s <= 26일 경우)
    num = int(pre + cur)
    if 10 <= num <= 26:
        dp[i] += dp[i-2]

print(dp[len(n)-1]%1000000)
```
예외 사항이라고 나오는 **0**에 대한 예외만 처리해주고 나머진 앞서 설명은 점화식대로 계산하면 끝!