---
title: "날씨 및 미세먼지 UI를 만들어보자"
date: "2025-12-08 16:43:20"
category: "개발"
description: "블로그 UI에 사용자 Ip 기반 날씨와 미세먼지를 보여주는 UI를 만들어보가"
---

## 공공기관 API를 활용한 날씨/미세먼지 UI 만들기
### 1. 설계하기
먼저 공공기관 API에서 항상 최상위권으로 사용되는 <strong>기상청_단기예보 조회서비스</strong> API를 활용해서 날씨를 보여줄 생각이었다.
내가 원하는 기능은 **현재 날씨에 대한 조회**이므로 조회서비스가 제공하는 4가지 API 중 **초단기실황조회** API를 사용할 예정이었다.

#### Request Parameter 명세

| 항목명(영문) | 항목명(국문) | 항목크기 | 항목구분 | 샘플데이터 | 항목설명 |
| :--- | :--- | :---: | :---: | :--- | :--- |
| **serviceKey** | 인증키 | 100 | 1 | 인증키<br>(URL Encode) | 공공데이터포털에서<br>발급받은 인증키 |
| **numOfRows** | 한 페이지 결과 수 | 4 | 1 | 10 | 한 페이지 결과 수<br>Default: 10 |
| **pageNo** | 페이지 번호 | 4 | 1 | 1 | 페이지 번호<br>Default: 1 |
| **dataType** | 응답자료형식 | 4 | 0 | XML | 요청자료형식(XML/JSON)<br>Default: XML |
| **base_date** | 발표일자 | 8 | 1 | 20210628 | ‘21년 6월 28일 발표 |
| **base_time** | 발표시각 | 4 | 1 | 0600 | 06시 발표(정시단위)<br>-매시각 10분 이후 호출 |
| **nx** | 예보지점 x좌표 | 2 | 1 | 55 | 예보지점의 x 좌표값 |
| **ny** | 예보지점 y좌표 | 2 | 1 | 127 | 예보지점의 y 좌표값 |

여기서 중요한 건 내가 만약 Ip 기반으로 x,y 좌표를 알 수 있다면 1페이지만 return하면 충분할 것이고,
일일 수용 가능한 트래픽의 양이 **10,000**으로 솔직히 내 블로그에 들어오는 모든 사람마다 fetch를 통해 실시간 반영을 해도 좋을 거 같지만
법정동에서 **동**단위의 구분을 가지고서 **redis cache**를 활용해 1시간 이내의 유효한 cache hit가 있다면 fetch하지 않고
즉시 cache값을 return하도록 구현해보고 싶었다.

공식문서에서 제공된 `응답메세지 명세` 표는 아래와 같다.

#### 응답 메시지 명세

| 항목명(영문) | 항목명(국문) | 항목크기 | 항목구분 | 샘플데이터 | 항목설명 |
| :--- | :--- | :---: | :---: | :--- | :--- |
| **numOfRows** | 한 페이지 결과 수 | 4 | 1 | 1 | 한 페이지당 표출<br>데이터 수 |
| **pageNo** | 페이지 번호 | 4 | 1 | 1 | 페이지 수 |
| **totalCount** | 데이터 총 개수 | 10 | 1 | 1 | 데이터 총 개수 |
| **resultCode** | 응답메시지 코드 | 2 | 1 | 00 | 응답 메시지코드 |
| **resultMsg** | 응답메시지 내용 | 100 | 1 | NORMAL SERVICE | 응답 메시지 설명 |
| **dataType** | 데이터 타입 | 4 | 1 | XML | 응답자료형식<br>(XML/JSON) |
| **baseDate** | 발표일자 | 8 | 1 | 20210628 | ‘21년 6월 28일 발표 |
| **baseTime** | 발표시각 | 6 | 1 | 0600 | 06시 발표(매 정시) |
| **nx** | 예보지점 X 좌표 | 2 | 1 | 55 | 입력한 예보지점 X<br>좌표 |
| **ny** | 예보지점 Y 좌표 | 2 | 1 | 127 | 입력한 예보지점 Y<br>좌표 |
| **category** | 자료구분코드 | 3 | 1 | RN1 | 자료구분코드<br>\* 하단 코드값 정보 참조 |
| **obsrValue** | 실황 값 | 2 | 1 | 0 | RN1, T1H, UUU, VVV, WSD<br>실수 또는 정수로 제공<br>\* 하단 코드값 정보 참조 |

※ 항목구분 : 필수(1), 옵션(0), 1 건 이상 복수건(1..n), 0 건 또는 복수건(0..n), 코드표별첨  
**category**에 따른 구분은 아래와 같았다.

| 예보구분 | 항목값 | 항목명 | 단위 | 압축bit수 |
| :--- | :--- | :--- | :--- | :---: |
| 초단기실황 | T1H | 기온 | ℃ | 10 |
| 초단기실황 | RN1 | 1시간 강수량 | mm | 8 |
| 초단기실황 | UUU | 동서바람성분 | m/s | 12 |
| 초단기실황 | VVV | 남북바람성분 | m/s | 12 |
| 초단기실황 | REH | 습도 | % | 8 |
| 초단기실황 | PTY | 강수형태 | 코드값 | 4 |
| 초단기실황 | VEC | 풍향 | deg | 10 |
| 초단기실황 | WSD | 풍속 | m/s | 10 |

여기서 내게 필요한 것은 **기온**, **강수형태**, **습도**, **1시간 강수량**, **풍향**, **풍속** 정도일 것이다.  
**강수형태**는 **초단기 기준** 없음(0), 비(1), 비/눈(2), 눈(3), 빗방울(5), 빗방울눈날림(6), 눈날림(7)이였다.  
친절하게도 공식문서에서 강수량 범주 및 표시 방법까지 제시해줬다.

마지막으로 **초단기예보**기준 <p style={red}>매시간 정시에 생성되고, 10분마다 최신 정보로 업데이트</p>되므로 정시:10분마다 뭔가 업데이트를
해야할 부분을 자동 수행하는 로직이 필요할 수도 있겠다.

여기서 고민이 생겼다.  
- **1. 새로 들어오는 사람마다 fetch를 통해 실시간 정보를 보여준다.**
    - 내 블로그에는 하루에 1만명이 들어올리가 없었다. 새로고침 횟수를 고려하더라도, 큰 문제는 없을 지도 모른다.
- **2. 상태 저장과 redis를 통한 캐시를 적극 활용한다.**
    - 정석적인 개발의 의미라면 이 방식이 무조건 맞다고 생각한다. 다만 이렇게될 경우 cache에 있는 $$x,y$$좌표들을 기반으로 매 시간 10분마다
    fetch를 통해 **최신화**를 거쳐야 했었다.

프론트엔트에서 상태 저장을 자주 활용하는 걸 봤었고, 프론트엔드에서 caching을 해본 적이 없어서 이 방법이 아주 매력적으로 느껴졌었다.  
우선 이 방법이 가능한지부터 LLM과 대화해보았다.

AI로부터 받은 피드백은 아주 훌륭했다.  
내가 궁금했던 질문에 대해서 깔끔한 대답과 그것을 바탕으로 내 기능을 어떤 식으로 구현해야할지를 상세히 설명해주었다.  
먼저, **Ip 기반 사용자 추적**에 대한 답변으로, **가능은 하나, 날씨용으로는 부정확하다**는 답변이 돌아왔다.  

`request-ip`나 Next.js의 `req.headers.get('x-forwarded-for')`를 통해서 사용자의 ip를 얻고 `geoip-lite`와 같은 DB나
`ipapi`와 같은 외부 API를 통해서 대략적인 위치(위도/경도)를 알 수 있긴 하다.  
문제는 이런 식으로 제공되는 위도 경도는 대부분 <strong>시/군/구</strong>단위까지만 정확하고 내가 구현하고픈 **동**단위까지는 맞지 않는다.

또한, 이 기능을 설계하면서 중요하게 생각했던 것 중 하나가 **모바일** 환경에 대한 고려였다.  
두 플랫폼으로 모두 제대로된 기능을 제공하기 위해선 모바일 환경의 네트워크와 PC 환경의 네트워크의 차이점을 알 필요가 있었다.  

<strong>PC(WiFi/LAN)</strong>은 비교적 통신사 기지국이나 인터넷 교환 노드 위치와 가까워서 '시' 단위까지는 맞을 가능성이 있다.  
하지만 <strong>모바일(LTE/5G)</strong>은 통신사의 <strong>NAT(Gateway) Ip</strong> 를 사용하기 때문에 ip 위치가 사용자의 위치가 아닌
라우터의 위치가 될 것이었다.

따라서 동단위의 정확도와 성능(캐싱)을 모두 잡기 위해선 **클라이언트의 GPS** **서버 캐싱**을 잘 설계할 필요가 있었다.

#### 설계 전체 흐름도
1.  **Client (브라우저):**
    *   `navigator.geolocation.getCurrentPosition()`을 사용해 사용자의 정확한 <strong>위도(Lat), 경도(Lon)</strong>를 얻기. (사용자 동의 필요)
    *   이 좌표를 서버 API (`/api/weather?lat=...&lon=...`)로 보낸다.
2.  **Server (Next.js Route Handler):**
    *   받은 위도/경도를 기상청 격자 좌표 **(nx, ny)로 변환**. (변환 공식 함수 필요)
    *   **Redis 조회:** Key `weather:${nx}:${ny}`가 존재하는지 확인.
        *   **Hit:** 저장된 날씨 데이터를 바로 `return`.
        *   **Miss:** 기상청 API를 요청 -> 결과를 Redis에 저장(TTL 1시간) -> `return`.
3.  **Client (UI):**
    *   받은 데이터를 예쁘게 보여주기.

사용자의 정확한 위치를 얻기 위해선 브라우저 내에서 자체적으로 사용자 위치 수집 여부를 묻게 될 텐데, 화면을 보여줄 때 바로 요청을 하는 것보단
기본적으로 **서울 종로**의 위치를 기반으로 날씨를 보여주다가 **내 위치 찾기**와 같은 버튼을 따로 만들어서 권한을 획득하는 게 UX적으로 훨씬
좋을 거 같아서 이런 방식을 적용하기로 했다!

따라서 내가 준비할 UI는 크게 3가지로 구분할 수 있었다.
- 1. <strong>기본 상태(Default)</strong>
    - 사용자가 아직 허용/거부를 누르기 전, 혹은 거부를 눌렀을 때 보여줄 <strong>기본 지역 날씨(서울 종로)</strong>.
- 2. <strong>로딩 상태(Loading)</strong>
    - 사용자가 내 위치 찾기 버튼을 눌러서 GPS 좌표를 따고 서버 API를 갖다 오는 동안 보여줄 로딩 화면.
- 3. <strong>에러/거부 상태(Error)</strong>
    - 사용자가 '차단'을 누르거나, 위치 정보를 불러올 수 없을 경우 보여줄 작은 안내 문구 or 기본 화면으로 보여주기.

