---
title: "날씨 및 미세먼지 UI를 만들어보자"
date: "2025-12-08 16:43:20"
category: "개발"
description: "블로그 UI에 사용자 Ip 기반 날씨와 미세먼지를 보여주는 UI를 만들어보가"
---

## 공공기관 API를 활용한 날씨/미세먼지 UI 만들기
### 1. 설계하기
먼저 공공기관 API에서 항상 최상위권으로 사용되는 <strong>기상청_단기예보 조회서비스</strong> API를 활용해서 날씨를 보여줄 생각이었다.
내가 원하는 기능은 **현재 날씨에 대한 조회**이므로 조회서비스가 제공하는 4가지 API 중 **초단기 실황조회** API를 사용할 예정이었다.

#### Request Parameter 명세

| 항목명(영문) | 항목명(국문) | 항목크기 | 항목구분 | 샘플데이터 | 항목설명 |
| :--- | :--- | :---: | :---: | :--- | :--- |
| **serviceKey** | 인증키 | 100 | 1 | 인증키<br>(URL Encode) | 공공데이터포털에서<br>발급받은 인증키 |
| **numOfRows** | 한 페이지 결과 수 | 4 | 1 | 10 | 한 페이지 결과 수<br>Default: 10 |
| **pageNo** | 페이지 번호 | 4 | 1 | 1 | 페이지 번호<br>Default: 1 |
| **dataType** | 응답자료형식 | 4 | 0 | XML | 요청자료형식(XML/JSON)<br>Default: XML |
| **base_date** | 발표일자 | 8 | 1 | 20210628 | ‘21년 6월 28일 발표 |
| **base_time** | 발표시각 | 4 | 1 | 0600 | 06시 발표(정시단위)<br>-매시각 10분 이후 호출 |
| **nx** | 예보지점 x좌표 | 2 | 1 | 55 | 예보지점의 x 좌표값 |
| **ny** | 예보지점 y좌표 | 2 | 1 | 127 | 예보지점의 y 좌표값 |

여기서 중요한 건 내가 만약 Ip 기반으로 x,y 좌표를 알 수 있다면 1페이지만 return하면 충분할 것이고,
일일 수용 가능한 트래픽의 양이 **10,000**으로 솔직히 내 블로그에 들어오는 모든 사람마다 fetch를 통해 실시간 반영을 해도 좋을 거 같지만
법정동에서 **동**단위의 구분을 가지고서 **redis cache**를 활용해 1시간 이내의 유효한 cache hit가 있다면 fetch하지 않고
즉시 cache값을 return하도록 구현해보고 싶었다.

공식문서에서 제공된 `응답메세지 명세` 표는 아래와 같다.

#### 응답 메시지 명세

| 항목명(영문) | 항목명(국문) | 항목크기 | 항목구분 | 샘플데이터 | 항목설명 |
| :--- | :--- | :---: | :---: | :--- | :--- |
| **numOfRows** | 한 페이지 결과 수 | 4 | 1 | 1 | 한 페이지당 표출<br>데이터 수 |
| **pageNo** | 페이지 번호 | 4 | 1 | 1 | 페이지 수 |
| **totalCount** | 데이터 총 개수 | 10 | 1 | 1 | 데이터 총 개수 |
| **resultCode** | 응답메시지 코드 | 2 | 1 | 00 | 응답 메시지코드 |
| **resultMsg** | 응답메시지 내용 | 100 | 1 | NORMAL SERVICE | 응답 메시지 설명 |
| **dataType** | 데이터 타입 | 4 | 1 | XML | 응답자료형식<br>(XML/JSON) |
| **baseDate** | 발표일자 | 8 | 1 | 20210628 | ‘21년 6월 28일 발표 |
| **baseTime** | 발표시각 | 6 | 1 | 0600 | 06시 발표(매 정시) |
| **nx** | 예보지점 X 좌표 | 2 | 1 | 55 | 입력한 예보지점 X<br>좌표 |
| **ny** | 예보지점 Y 좌표 | 2 | 1 | 127 | 입력한 예보지점 Y<br>좌표 |
| **category** | 자료구분코드 | 3 | 1 | RN1 | 자료구분코드<br>\* 하단 코드값 정보 참조 |
| **obsrValue** | 실황 값 | 2 | 1 | 0 | RN1, T1H, UUU, VVV, WSD<br>실수 또는 정수로 제공<br>\* 하단 코드값 정보 참조 |

※ 항목구분 : 필수(1), 옵션(0), 1 건 이상 복수건(1..n), 0 건 또는 복수건(0..n), 코드표별첨  
**category**에 따른 구분은 아래와 같았다.

| 예보구분 | 항목값 | 항목명 | 단위 | 압축bit수 |
| :--- | :--- | :--- | :--- | :---: |
| 초단기실황 | T1H | 기온 | ℃ | 10 |
| 초단기실황 | RN1 | 1시간 강수량 | mm | 8 |
| 초단기실황 | UUU | 동서바람성분 | m/s | 12 |
| 초단기실황 | VVV | 남북바람성분 | m/s | 12 |
| 초단기실황 | REH | 습도 | % | 8 |
| 초단기실황 | PTY | 강수형태 | 코드값 | 4 |
| 초단기실황 | VEC | 풍향 | deg | 10 |
| 초단기실황 | WSD | 풍속 | m/s | 10 |

여기서 내게 필요한 것은 **기온**, **강수형태**, **습도**, **1시간 강수량**, **풍향**, **풍속** 정도일 것이다.  
**강수형태**는 **초단기 기준** 없음(0), 비(1), 비/눈(2), 눈(3), 빗방울(5), 빗방울눈날림(6), 눈날림(7)이였다.  
친절하게도 공식문서에서 강수량 범주 및 표시 방법까지 제시해줬다.

**초단기 실황조회**는 <span style={{ color: 'red' }}>매시간 정시에 생성되고, 10분마다 최신 정보로 업데이트</span>되므로 hh:10마다 뭔가 업데이트를
해야할 부분을 자동 수행하는 로직이 필요할 수도 있겠다.

그렇게 순탄하게 기획이 되어가던 중에 문제가 발생했다.  
초단기 실황조회는 <strong>하늘 상태(SKY)</strong>에 대한 정보를 제공하지 않는다는 것이다.  
단순히 강수형태만 제공하기 때문에 **맑음**과 **흐림**을 구분할 수가 없었다. 이는 날씨 제공 UI에 있어서 상당히 치명적이라고 생각했다.

따라서 계획을 약간 수정하기로 했다, **초단기예보**의 경우에는 하늘 상태를 제공해준다.  
다만, 초단기예보는 **예보**인만큼 정보제공이 약간 달랐다. <span>매시간 30분에 생성되고, 10분마다 최신 정보로 업데이트되며, 실제 api 제공 시간은 45분</span>이었다. 따라서 둘 다 10분 정도의 시간차를 줘서 api 제공을 안정적으로 받을 수 있게 하려면, 실황은 20분, 예보는 55분을 기준으로 이보다 작은 시간에 요청이 들어올 경우 -1시간의 정보를 바탕으로 제공해주기로 결정했다.

<details>
<summary>
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 2h10v2H6V2zM4 6V4h2v2H4zm0 12H2V6h2v12zm2 2H4v-2h2v2zm12 0H6v2h12v-2zm2-2v2h-2v-2h2zm0 0h2V8h-2v10zM12 6H8v2H6v8h2v2h8v-2h2v-4h-2v4H8V8h4V6zm2 8v-4h2V8h2V6h4V4h-2V2h-2v4h-2v2h-2v2h-4v4h4z" fill="currentColor"/></svg>
<span className="text-red-400">트러블 슈팅</span>
</summary>

**문제 상황**  
로컬 환경(한국)에서 현재 시간을 기준으로 기상청 API 요청 시간(`base_time`)을 계산할 때는 문제가 없었다. 하지만 <code>new Date()</code>를 사용하여 단순히 시간을 계산하니, 배포 환경(Vercel, UTC 기준)이나 브라우저의 시간대 설정에 따라 시간이 엉뚱하게 계산되는 현상이 발생했다.

예를 들어 한국 시간 00시 30분에 요청을 보냈는데, API 요청 파라미터에는 전날 15시 30분(UTC)이 들어가거나, 시차 보정을 위해 `+9시간`을 수동으로 했더니 브라우저가 자동으로 또 9시간을 더해서 **09시 30분**으로 미래의 시간을 요청하는 문제가 생겼다.

**원인**  
자바스크립트의 `Date` 객체는 실행되는 환경(브라우저/OS)의 시간대(Timezone)에 영향을 받기 때문이었다. `getHours()` 같은 메서드는 로컬 시간을 반환하기 때문에, 서버와 클라이언트 간의 불일치가 발생한다.

**해결 방법**  
실행 환경에 상관없이 **'절대 시간(UTC)'**을 기준으로 계산하되, 한국 시차만큼 강제로 이동시킨 후 `toISOString()`을 사용하는 방식으로 해결했다.

```javascript
// 1. 현재 시스템의 절대 시간(UTC)을 가져옴
const now = new Date();

// 2. UTC 시간에 강제로 9시간(korea offset)을 더해버림 (밀리초 단위 계산)
// 이렇게 하면 kstDate 객체 내부의 UTC 시간은 사실상 '한국 시간'이 됨
const kstDate = new Date(now.getTime() + (9 * 60 * 60 * 1000));

// 3. toISOString()은 무조건 UTC 시간을 문자열로 뱉어냄
// 위에서 강제로 시간을 변조했으므로, 이 문자열이 곧 한국 시간이 됨
const baseDate = kstDate.toISOString().slice(0, 10).replace(/-/g, "");
const baseTime = kstDate.toISOString().slice(11, 13) + "00";
```

</details>

여기서 고민이 생겼다.  
- **1. 새로 들어오는 사람마다 fetch를 통해 실시간 정보를 보여준다.**
    - 내 블로그에는 하루에 1만명이 들어올리가 없었다. 새로고침 횟수를 고려하더라도, 큰 문제는 없을 지도 모른다.
- **2. 상태 저장과 redis를 통한 캐시를 적극 활용한다.**
    - 정석적인 개발의 의미라면 이 방식이 무조건 맞다고 생각한다. 다만 이렇게될 경우 cache에 있는 $$x,y$$좌표들을 기반으로 매 시간 10분마다
    fetch를 통해 **최신화**를 거쳐야 했었다.

프론트엔트에서 상태 저장을 자주 활용하는 걸 봤었고, 프론트엔드에서 caching을 해본 적이 없어서 이 방법이 아주 매력적으로 느껴졌었다.  
우선 이 방법이 가능한지부터 LLM과 대화해보았다.

AI로부터 받은 피드백은 아주 훌륭했다.  
내가 궁금했던 질문에 대해서 깔끔한 대답과 그것을 바탕으로 내 기능을 어떤 식으로 구현해야할지를 상세히 설명해주었다.  
먼저, **Ip 기반 사용자 추적**에 대한 답변으로, **가능은 하나, 날씨용으로는 부정확하다**는 답변이 돌아왔다.  

`request-ip`나 Next.js의 `req.headers.get('x-forwarded-for')`를 통해서 사용자의 ip를 얻고 `geoip-lite`와 같은 DB나
`ipapi`와 같은 외부 API를 통해서 대략적인 위치(위도/경도)를 알 수 있긴 하다.  
문제는 이런 식으로 제공되는 위도 경도는 대부분 <strong>시/군/구</strong>단위까지만 정확하고 내가 구현하고픈 **동**단위까지는 맞지 않는다.

또한, 이 기능을 설계하면서 중요하게 생각했던 것 중 하나가 **모바일** 환경에 대한 고려였다.  
두 플랫폼으로 모두 제대로된 기능을 제공하기 위해선 모바일 환경의 네트워크와 PC 환경의 네트워크의 차이점을 알 필요가 있었다.  

<strong>PC(WiFi/LAN)</strong>은 비교적 통신사 기지국이나 인터넷 교환 노드 위치와 가까워서 '시' 단위까지는 맞을 가능성이 있다.  
하지만 <strong>모바일(LTE/5G)</strong>은 통신사의 <strong>NAT(Gateway) Ip</strong> 를 사용하기 때문에 ip 위치가 사용자의 위치가 아닌
라우터의 위치가 될 것이었다.

따라서 동단위의 정확도와 성능(캐싱)을 모두 잡기 위해선 **클라이언트의 GPS** **서버 캐싱**을 잘 설계할 필요가 있었다.

#### 설계 전체 흐름도
1.  **Client (브라우저):**
    *   `navigator.geolocation.getCurrentPosition()`을 사용해 사용자의 정확한 <strong>위도(Lat), 경도(Lon)</strong>를 얻기. (사용자 동의 필요)
    *   이 좌표를 서버 API (`/api/weather?lat=...&lon=...`)로 보낸다.
2.  **Server (Next.js Route Handler):**
    *   받은 위도/경도를 기상청 격자 좌표 **(nx, ny)로 변환**. (변환 공식 함수 필요)
    *   **Redis 조회:** Key `weather:${nx}:${ny}`가 존재하는지 확인.
        *   **Hit:** 저장된 날씨 데이터를 바로 `return`.
        *   **Miss:** 기상청 API를 요청 -> 결과를 Redis에 저장(TTL 1시간) -> `return`.
3.  **Client (UI):**
    *   받은 데이터를 예쁘게 보여주기.

사용자의 정확한 위치를 얻기 위해선 브라우저 내에서 자체적으로 사용자 위치 수집 여부를 묻게 될 텐데, 화면을 보여줄 때 바로 요청을 하는 것보단
기본적으로 **서울 종로**의 위치를 기반으로 날씨를 보여주다가 **내 위치 찾기**와 같은 버튼을 따로 만들어서 권한을 획득하는 게 UX적으로 훨씬
좋을 거 같아서 이런 방식을 적용하기로 했다!

따라서 내가 준비할 UI는 크게 3가지로 구분할 수 있었다.
- 1. <strong>기본 상태(Default)</strong>
    - 사용자가 아직 허용/거부를 누르기 전, 혹은 거부를 눌렀을 때 보여줄 <strong>기본 지역 날씨(서울 종로)</strong>.
- 2. <strong>로딩 상태(Loading)</strong>
    - 사용자가 내 위치 찾기 버튼을 눌러서 GPS 좌표를 따고 서버 API를 갖다 오는 동안 보여줄 로딩 화면.
- 3. <strong>에러/거부 상태(Error)</strong>
    - 사용자가 '차단'을 누르거나, 위치 정보를 불러올 수 없을 경우 보여줄 작은 안내 문구 or 기본 화면으로 보여주기.

