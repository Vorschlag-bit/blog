---
title: "백준 2167번 2차원 배열의 합(python)"
date: "2025-11-24 05:04:06"
category: "코테"
description: "python으로 풀어보는 백준 2167번"
---

## 코딩테스트 풀이

### 문제 사진
!["문제사진"](/images/2167.png)\
[문제 링크]("https://www.acmicpc.net/problem/2167")

백준 2167번 문제 풀이에 대한 해설.

필자는 코딩테스트에서 **DP**와 **누적합**이 많이 약한 편이라서 2가지 위주로 연습을 하려고 한다.

그래서 백준에 있는 누적합과 dp 문제들을 난이도와 상관없이 풀 예정.

이 문제는 단순히 2차원 배열에서 x1,y1,x2,y2 (x1 < x2, y1 < y2)의 합을 구하는 문제였다.

당연하게도 단순한 완전탐색을 사용한다면 시간초과가 발생하는 문제이다.\
이러한 문제에서는 **누적합**을 사용해서 접근해야 한다.

우선 거두절미하고 정답코드를 봐보자.

### 정답 코드
```python
from sys import stdin as input

n,m = map(int,input.readline().split())
arr = []
for _ in range(n):
    arr.append([0] + list(map(int,input.readline().split())))
k = int(input.readline())

cmd = []
for _ in range(k):
    i,j,x,y = map(int,input.readline().split())
    cmd.append((i,j,x,y))

# 누적합 계산
for i in range(n):
    for j in range(1,m+1):
        arr[i][j] += arr[i][j-1]

# i,j부터 x,y 위치에 저장되어 있는 수의 합 구하기
for i,j,x,y in cmd:
    s = 0
    for r in range(i,x+1):
        s += arr[r-1][y] - arr[r-1][j-1]
    print(s)
```

문제는 어렵지 않았지만 인덱스 관리가 헷갈려서 디버깅하느라 많은 시간을 쏟았었다. 실제 문제에서 인덱스 관리로 시간이 쫓기면 매우 치명적이므로 LLM에서 누적합 문제에서 공식처럼 외울 팁을 달라고 했다.

### AI의 누적합을 공식처럼 푸는 3가지 원칙

#### 1. 배열 크기는 무조건 `(n+1) * (m+1)`로 잡는다.
입력이 N * M이라면, 누적합 배열은 반드시 가로,세로로 한 칸씩 늘려서 초기화한다.

이렇게 하고 0번 행과 열을 0으로 초기화해두면, idx - 1을 계산할 때 `if idx < 0`과 같은 경계값 계산을 염두할 필요가 사라진다.

#### 2. 데이터 입력은 `(1,1)`로 시작한다.
원본 데이터를 받을 때도 인덱스 혼동이 오지 않기위해 **입력받은 좌표 그대로** 누적합 배열에 매칭한다.

보통 누적합 문제에선 인덱스를 `1-based`로 주기 때문에 그대로 사용하면 된다.

```python
# 원본 배열 arr이 있다고 가정할 경우
for i in range(1,n+1):
    for j in range(1,m+1):
        # arr[i-1][j-1]이 원본 데이터
        pre_sum[i][j] = pre_sum[i-1][j] + pre_sum[i][j-1] - pre_sum[i-1][j-1] + arr[i-1][j-1]

```
내가 풀이한 건 행마다 합을 구한 코드였지만 2차원 누적합에선 **면적 합** 공식을 사용하는 게 훨씬 빠르다.\
여기서 면적합에 사용된\
`pre_sum[i][j] = pre_sum[i-1][j] + pre_sum[i][j-1] - pre_sum[i-1][j-1] + arr[i-1][j-1]` 코드를
시각적으로 쉽게 이해하기 위해서 아래의 사진을 준비했다!

!["누적합_설명_사진"](/images/pre_fix_details.png)

위의 사진은 0-based 인덱스를 가진 배열에서 (1,2)까지의 면적합을 구하는 방식을 설명하는 그림이다.\
(0,0) ~ (x,y)의 면적합을 저장하는 배열 preSum과 그냥 원본 배열 arr이 있다는 가정 하에 설명하면\
<span style="color:#e03131">1. (1,2) 위쪽의 직사각형의 누적합을 더해서 위 부분을 커버한다(= preSum[i-1][j])</span>
<span style="color:#2f9e44">2. (1,2) 왼쪽의 직사각형의 누적합을 더해서 왼쪽 부분을 커버한다(= preSum[i][j-1])</span>
<span style="color:#f08c00">3. 앞의 1,2번의 커버 공간 중 중복된 사각형을 제거한다(= preSum[i-1][j-1])</span>
<span style="color:#f08c00">4. 원본 배열에서 원하는 구간의 값만 더해서 직사각형의 면적합을 완성한다.(= arr[i][j])</span>


