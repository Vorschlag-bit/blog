---
title: "백준 10986번 나머지 합(python)"
date: "2025-11-24 12:01:52"
category: "코테"
description: "python으로 풀어보는 백준 10986"
---

## 코딩 테스트 풀이

### 문제 사진
!["문제사진"](/images/rest_sum.png)
<a href="https://www.acmicpc.net/problem/10986" style="color: #2f9e44; text-decoration: none;">
문제 링크
</a>

백준 10986번 문제 풀이에 대한 해설.

처음에는 이와 비슷한 문제인 ["부분합"](https://www.acmicpc.net/problem/1806)이 생각이 나서\
**투 포인터**와 **누적합**을 사용해서 플려고 했었다.\
하지만 이 문제는 투 포인터의 특징인 **구간이 길어지면 합이 커지고, 짧아지면 합이 줄어드는** 단조증가의 성질을 갖고 있지 않았다.
문제에서 요구하는 **나누어 떨어진다는 특성**은 단조롭지 않기 때문이다.

따라서 처음엔 투 포인터를 통해 l 인덱스의 증가 계기는 뭘까로 고민을 하다가 도저히 생각이 안 나서\
AI의 힌트를 받았다. 이 문제는 투 포인터처럼 보이는 **수학**과 **조합**을 사용하는 문제이다.

우리가 사용하는 누적합의 공식은 아래와 같다.

$$ \text{구간 합}(i, j) = S[j] - S[i-1] $$

이 구간합이 M으로 나누어 떨어지기 위해선 양 쪽 항을 M으로 나누고 구간합 % M == 0이 된다.\
즉 아래와 같은 식이 유도된다.

$$ S[j] \% M = S[i-1] \% M $$

따라서 이 문제의 핵심은 **M으로 나눈 나머지가 같은 2구간 뽑는 조합**의 개수를 세는 것이다.

하지만 이렇게 해도 한 가지 함정이 존재한다.\
그건 바로 누적합 자체가 M으로 나누어 떨어지는 경우이다.

문제의 예제 입력을 살펴보면
```python
5 3
1 2 3 1 2
```

0-based 인덱스에서 0(=1)부터 2(=3)까지의 누적합인 6은 그 자체로 M의 나머지가 0인 경우이다.\
이 경우에는 혼자서는 짝을 지을 수 없으므로 정답에 속하나 조합을 생성할 수 없는 문제가 발생한다.\
이를 해결하기 위해선 맨 앞에 0을 추가해서 최소한 2개 이상의 나머지가 0인 값을 보장해주면 된다!

뿐만 아니라 나머지가 0인 개수가 여러 개인 경우도 생각해보자.\
예를 들어 누적합[i] % m을 보관하는 1-based 인덱스의 배열이 있다고 가정하자.
$$ [0, 1, 0, 1, 0] $$
위의 경우 정답의 경우의 수는 2가지이다.
#### 1. 나머지가 같은 것끼리 조합(rC2)
나머지가 1인 인덱스(1,3)에서 2개를 뽑으니 1의 경우의 수가 존재한다.

#### 2. 나머지가 0인 누적합
나머지가 0인 인덱스인 (2,4)에 임의로 넣어둔 0을 포함하면 총
3개의 인덱스가 나머지 0을 갖게된다. (0,2,4)

이 경우의 수는 3이 되는데\
**1. 누적합 자체가 0이 되는 경우의 수(=2,4)**\
2,4는 그 자체로 정답이다. (현재까지 총 2)\
**2. 같은 나머지를 가진 수끼리의 조합**\
2,4는 서로 같은 나머지를 가진 조합으로서도 정답이다. (2C2 = 1)\
따라서 총 정답은 3이 되고 이는 3C2의 값과 일치하기 때문에\
우리는 모든 나머지에 대해서 일관성있는 조합 공식을 사용할 수 있게 된다.

### 정답 코드
```python
from sys import stdin as input
n,m = map(int,input.readline().split())
arr = [0] + list(map(int,input.readline().split()))
ans = 0

# 나머지 개수를 보관할 배열(0~m-1)
cnt = [0] * m

for i in range(1,n+1):
    arr[i] += arr[i-1]

# 어떤 두 지점의 누적합을 나눈 나머지가 서로 같다면 두 지점 사이의 누적합은 반드시 m으로 나눠진다.
for i in range(n+1):
    r = arr[i] % m
    cnt[r] += 1

# cnt[r] >= 2이라면 rC2
for i in range(m):
    if cnt[i] >= 2:
        ans += cnt[i] * (cnt[i] - 1) // 2

print(ans)
```

단순히 알고리즘(투 포인터)로 문제를 풀 수 있고 최근에는 그런 태도로 문제를 접근했었는데, 이렇게 수학적 특성을 이용하는 문제를 만나니 정말 쉽지 않았다..

역시 개발자라면 수학도 어느 정도는 필수적으로 익혀야 하나보다.\
정말 좋은 문제를 만나서 좋은 자극을 받은 것 같다.\
문제를 다양한 각도로 분석하는 태도를 언제쯤 갖출 수 있을런지;

