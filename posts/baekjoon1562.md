---
title: "백준 1562번 계단 수 (python)"
date: "2025-11-30 12:26:41"
category: "코테"
description: "python으로 풀어보는 백준1562"
---

## 코딩 테스트 풀이

!["문제사진"](/images/1562.png)
<a href="https://www.acmicpc.net/problem/1562" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 1562번 문제 풀이에 대한 해설.

### 나의 접근

<a href="https://www.acmicpc.net/problem/10844" style="color: #2f9e44; text-decoration: none;">
  쉬운 계단 수
</a>
의 후신 같은 문제였다. 쉬운 계단 수가 단순 <strong>dp</strong>와 조건문을 사용한 문제였다면 이 문제는 좀 달랐다.

쉬운 계단 수는 길이가 n인 계단 수의 개수를 출력하기 때문에 2차원 dp배열을 선언해서  
$$ dp[i][j] = i자리 수에 숫자 j가 들어갈 때의 경우의 수 $$\
라고 생각하고 처음과 끝인 0과 9의 경우는 각각 +1과 -1에서의 수만 더하고, 나머진 +1,-1을 모두 고려하면 됐다.

하지만 이 문제는 **0부터 9까지 숫자가 모두 등장하는** n자리의 계단 수 개수를 출력하는 문제이다.  
이전 쉬운 계단 수는 **현재 자리 수에 들어갈 숫자와 이전 자리에 들어간 숫자**만 파악할 수 있게 점화식을 짰었다.  
그러나 이 문제는 매 순간 dp를 계산할 때, **이전까지 누적된 계단 수의 상태**를 알아야지만 문제 요구사항인 0~9까지의 모든 수가
포함된 계단 수의 개수를 출력할 수 있었다.

이전까지는 이런 문제를 풀어본 적이 없었기 때문에 고민하다가 문제 유형 힌트를 확인했고, **비트마스킹**을 요구하는 문제라는 걸 알고나서
내가 비트마스킹에 대한 개념도 제대로 잡혀있지 않아서 비트마스킹에 대한 개념을 빠르게 학습하고 풀이를 재개했다.

### 비트마스킹이란?
비트마스킹의 핵심은 **출석부 압축**이라고 생각하면 된다.  
이 문제에서 우리가 알고 싶은 건 결국 **0부터 9까지 숫자**가 전부 등장했는지 아닌지 체크하는 것이다.  
일반적인 경우 `dp[i][j][k]`의 3차원 배열을 사용하고 마지막 3차원 배열엔 `Boolean` 타입의 배열을 사용할 것이다.
```python
# [0번 등장여부, 1번 등장여부, ..., 9번 등장여부]
visited = [False, False, False, True, ..., False]
```
하지만 dp 테이블(`dp[N][10][?]`)의 인덱스에 저 긴 리스트를 통째로 넣을 순 없다. 
그래서 이 정보를 **하나의 숫자로 압축하는 기술**이 필요해지고, 이게 곧 비트마스킹이다.

전구 10개를 나란히 둔다고 생각을 해보자.  
**꺼짐 = 0**으로 **켜짐 = 1**로 표현하고, 오른쪽 끝부터 0, 마지막을 9라고 가정하면, 숫자 **2**가 등장할 경우
`0000000100`(=4)으로 표현이 가능하고, **0,2**가 등장할 경우엔 `0000000101`(=5)로 표현이 가능하다.
즉, **2진수**로 표현이 가능하고, 이를 10진수로 연산한 값에 경우의 수를 누적시키면 되는 것이다.  
또한 이 비트연산을 쉽게 도와주는 **비트연산자**를 통해서 아주 쉽게 연산이 가능해지는데  

#### 1. Shift 연산자(`<<`)
`1 << n`이라는 시프트 연산자는 숫자 1을 n칸 오른쪽으로 밀어라라는 의미이다. 즉, n번 전구를 켜라라는 의미.  
- `1 << 0: - `1 << 0: 0000000001` (0번 전구 선택) -> 값 = 1` (0번 전구 선택) -> 값 = 1
- `1 << 2: 0000000100` (2번 전구 선택) -> 값 = 4

#### 2. OR 연산자(`|`)
`A | B`라는 OR 연산자는 **A와 B 둘 중 하나라도 켜져 있다면 켜라**라는 의미이다. 이것은 **기존 상태에 새로운 값을 추가할 때 사용한다**.  
- 현재 상태: `0000000100` (2번만 on)
- 새로운 숫자 **1**을 켜야 함: `1 << 1` -> `0000000110`

또한 OR 연산자는 이미 1인 값에 대해서 중복으로 계산해서 아무런 변화없이 그대로 유지되기 때문에 이렇게 기존 상태를 유지하면서
새로운 값을 추가하는 데에 아주 적절하다.

### 이 문제에서 비트마스크 적용
예를 들어 **210**이라는 계단 수를 만드는 과정에 대해서 생각해보면  
- **1. 숫자 2**
    - 현재 상태 = 0
    - 2번 전구 on (`1 << 2`)
    - 계산 = `0 | (1 << 2)` = `0000000100` (= 십진수 4)
    - dp[1][2][4]에 기록

- **2. 숫자 1**
    - 현재 상태 = 4 (0000000100)
    - 1번 전구 on (`1 << 1`)
    - 계산 = `4 | (1 << 1)` = `0000000110` (= 십진수 6)
    - dp[2][1][6]에 기록
- **3. 숫자 0**
    - 현재 상태 = 6 (0000000110)
    - 0번 전구 on (`1 << 0`)
    - 게산 = `6 | (1 << 0)` = `0000000111` (= 십진수 7)
    - dp[3][0][7]에 기록

최종 목표는 **n자리 수에 0-9까지 모두 등장**하는 것이므로, 0번 전구부터 9번 전구까지 모두 1로 차있는  
`1111111111` (= 십진수 2^10 -1 = 1023). 즉 `sum(dp[N][0~9][1023])`이 우리가 원하는 답이 된다.

### 정답 코드
```python
n = int(input())
dp = [[[0] * 1024 for _ in range(10)] for _ in range(n+1)]
# 1자리 수에 i라는 숫자가 들어가는 경우(1을 i칸 이동)
# ex: 0000000001, 0000000010, 0000000100...
for i in range(1,10):
    dp[1][i][1 << i] = 1

# 현재 숫자 길이
for i in range(1,n):
    # 현재 끝자리 숫자
    for j in range(10):
        # 지금까지 켜진 숫자들의 스위치 상태
        for k in range(1024):
            # 존재할 수 없는 숫자면 pass
            if dp[i][j][k] == 0: continue

            # -1
            if j - 1 >= 0:
                nxt = k | (1 << (j-1))
                dp[i+1][j-1][nxt] += dp[i][j][k]
            # +1
            if j + 1 <= 9:
                nxt = k | (1 << (j+1))
                dp[i+1][j+1][nxt] += dp[i][j][k]

ans = 0
for i in range(10):
    ans += dp[n][i][1023]
print(ans % 1000000000)
```

### 후기
DP 문제를 풀면서 가장 어려운 점은 `dp[i]`에 대한 점화식을 세울 때, 뒤에 영향을 주는 걸 생각해야할지 아니면
이전 값으로부터 영향을 어떻게 받는지에 대해서 생각할지를 결정하는 일인 거 같다.

보통 뒤를 보는 방식(Pull dp)는 **지금 i에 있어서 과거 i-1에서는 무슨 일이 있었어야 했는지**를 생각해보자.  
적합한 문제들은 **LCS, 배낭 문제, 일반적인 최적화 문제** 등이 있다.  
반면 앞을 보는 방식(Push dp)는 **현재 i를 기준으로 미래 i+1에 어떤 영향을 줄 수 있는지**를 생각한다.  
적합한 문제들은 **비트마스킹, 그래프 탐색, 시뮬레이션**  등이 있다.

이 문제(비트마스킹)의 경우, 왜 Push를 써야 했는지 생각해보자.  
`111`이라는 현재의 비트가 주어질 경우, 만약 Pull dp였다면 경우의 수가 복잡해진다.  
`111`이라는 비트가 어디서부터 왔나를 고려해보면 `110`, `101`, `011`과 같이 다양한 경우가 존재한다.
반면 Push dp 방식으로 생각하면 단순히 현재 비트에서 특정 비트가 추가될 때의 미래만 고려하면 되기 때문에 이 문제는 **Push dp** 유형이 적합하다고 판단할 수 있었다.