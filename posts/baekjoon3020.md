---
title: "백준 3020번 개똥벌레(python)"
date: "2025-11-27 04:53:58"
category: "코테"
description: "python으로 풀어보는 백준 3020"
---

## 코딩테스트 풀이

### 문제 사진
!["백준_3020"](/images/3020.png)

<a href="https://www.acmicpc.net/problem/3020" style="color: #2f9e44; text-decoration: none;">
  문제링크
</a>

백준 3020번 문제 풀이에 대한 해설.

이 문제는 기존의 정방향(0부터 n-1)으로 누적합을 쌓는 게 아닌, 역방향으로 쌓는 문제였다.\
이 문제에서 누적합을 역방향으로 쌓는 것에 대한 의미를 파악하느냐 마느냐가 제일 중요했던 문제같다.

설명을 좀 더 쉽게 하기 위해 아래의 사진을 보자.
!["3020_설명"](/images/3020_detail.png)

1~3번째 그림은 입력값으로 받은 특정 높이의 죽순(혹은 종유석)에 +1을 시켜 해당 높이의 개수를 세는 것이다.\
4번째 그림은 모든 입력이 다 끝나면 역인덱스로 값을 누적하는 그림이다.\
이렇게 함으로써 **특정 높이(= 인덱스) 이상의 개수**를
한 번에 알 수 있게 된다. 예를 들어 높이가 2이상인 죽순의 개수는 3이라는 것이다.

이후에는 1부터 높이 h까지에 대한 죽순과 종유석의 해당 높이 이상의 개수를 더하고 그 최솟값과 개수를 세면 된다.\
다만 여기서 또 중요한 것은 벌레의 나는 높이는 **바닥**을 기준으로 날기 때문에 종유석의 경우 바닥 기준의 상대 높이로
전환을 해줘야한다. 예를 들어 높이가 4인 동굴에서 벌레의 높이가 1일 경우 죽순[1] + 종유석[4]의 합이 총 충돌 횟수인 셈이다.

### 정답 코드
```python
from sys import stdin as input

n,h = map(int,input.readline().split())

# 죽순 누적합
up = [0] * (h+1)
# 종유석 누적합
down = [0] * (h+1)

i = 0
for _ in range(n):
    num = int(input.readline())
    if i % 2 == 0:
        up[num] += 1
    else:
        down[num] += 1
    i += 1

# 누적합을 역으로 쌓는 의미: 높이(인덱스) 이상의 값의 개수
for i in range(h-1,0,-1):
    up[i] += up[i+1]
    down[i] += down[i+1]

ans = float('inf')
cnt = 0

for i in range(1,h+1):
    c = up[i] + down[h + 1 - i]
    if c < ans:
        ans = c
        cnt = 1
    elif c == ans:
        cnt += 1
print(f"{ans} {cnt}")
```

### 후기
이번 문제도 또 새로운 유형의 누적합이여서 정말 어려웠었다.\
누적합의 다양한 이용방법을 알아가는 중이라 실제 코딩테스트에서도 능숙하게 사용할 수 있을만큼
빨리 더 실력을 길러야겠다.